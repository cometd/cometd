Initial connection setup specifies to the system a message envelope type for
all communications on a particular channel, but inside this envelope a
normalized JSON structure is used to communicate with all endpoints.

The event router is channel based, with rules based on longest-prefix match
dispatching for registered listeners. The "/meta/*" channel is reserved for
communications with the event router itself (including connection setup,
tear-down, and re-connection), and all conformant clients and servers must
implement the following meta-channel  verbs:
	
	* handshake
	* connect
	* reconnect
	* disconnect
	* status
	* subscribe
	* unsubscribe
	* ping

All cometd /meta/ channel messages contain a protocol version number and all
messages generated from (or routed through) an event router contain a message
ID which is unique to the router. No randomness is required in these
identifiers although routers are expected to drop messages which they have
previously "seen".

All cometd messages are encoded in JSON format, but information in discrete
messages MAY be repeated in HTTP headers in order to speed message routing.
This is an example of the messages exchanged durring a connection setup
process:

	// from client, to server
	{
		"channel":			"/meta/handshake",
		// all meta channel messages MUST contain the protocol version the
		// client expects
		"version":			0.1,
		// the oldest version of the protocol that this client will support
		"minimumVersion":	0.1,
		// the authScheme is outside the realm of this specification and
		// provided here for illustration only. It's also optional.
		"authScheme":		"SHA1",
		// the authUser and authToken are optional and authScheme dependent
		"authUser":			"alex",
		"authToken":		"HASHJIBBERISH"
	}

	// NOTE: data should be POSTed with an encoding of
	// application/x-www-form-urlencoded, and the preceeding payload is
	// expected to be stored in the "message" parameter

	// from server, to client
	{
		"channel":					"/meta/handshake",
		// preferred protocol version
		"version":					0.1,
		// the oldest version of the protocol that this server will support
		"minimumVersion":			0.1,
		"supportedConnectionTypes":	["iframe", "flash", "http-polling"],
		"clientId":					"SOME_UNIQUE_CLIENT_ID"
		"authSuccessful":			true,
		// authToken is auth scheme dependent and entirely optional
		"authToken":				"SOME_NONCE_THAT_NEEDS_TO_BE_PROVIDED_SUBSEQUENTLY",
	}

	// finally, the client opens up a tunnel by creating a new iframe whose
	// initial contents were retreived from the following URL:
	//		http://blah.endpoint.com/cometd/?tunnelInit=iframe&domain=endpoint.com
	// this is an unfortunate workaround for some cross-domain intialization
	// issues with iframes. Ideally the "tunnelInit" block will never need to
	// be sent for most transports.
	//
	// here's what the client then POST's:
	{
		"channel":	"/meta/connect",
		"clientId":	"SOME_UNIQUE_CLIENT_ID",
		"connectionType": "iframe",
		// optional
		"authToken":"SOME_NONCE_PREVIOUSLY_PROVIDED_BY_SERVER"
	}

	// NOTE: data should be POSTed with an encoding of
	// application/x-www-form-urlencoded, and the preceeding payload is
	// expected to be stored in the "message" parameter

	// the server now replies with the preamble followed by any number of
	// messages encoded in the tunnel-specific envelope:
	<!-- begin preamble -->
	<html>
		<head>
			<title>Comet -- cleaning up web development</title>
			<script type="text/javascript">
				window.parent.cometd.deliver({
					// user-sent data
					"channel":		"/meta/connect",
					"successful":	true,
					"error":		"",
					"connectionId":	"/meta/connections/26",
					"timestamp":	"TimeAtServer",
					// optional
					"authToken":	"SOME_NONCE_THAT_NEEDS_TO_BE_PROVIDED_SUBSEQUENTLY"
				});
			</script>
		</head>
		<body>
	<!-- end preamble -->
	<!-- begin envelope -->
			<script type="text/javascript">
				window.parent.cometd.deliver({
					// user-sent data
					"data": {
						"someField":	["some", "random", "values"],
					},
					// the usual message meta-data
					"channel":		"/originating/channel",
					"id":			"slkjdlkj30",
					"timestamp":	"TimeAtServer",
					// optional meta-data
					"authToken":	"SOME_NONCE_THAT_NEEDS_TO_BE_PROVIDED_SUBSEQUENTLY"
				});
			</script>
			<br><!-- insert 2K of whitespace here -->
	<!-- end envelope -->
	...
	<!-- begin signoff -->
			<script type="text/javascript">
				window.parent.cometd.tunnelCollapse();
			</script>
		</body>
	</html>
	<!-- end signoff -->
	
Upon connection, clients are implicitly subscribed to a connection-specific
channel located at:

	/meta/clients/[SOME_UNIQUE_CLIENT_ID]

The client ID turns out to be very important to subsequent connection.

	// reconnection is very similar to initial connection:
	{
		"channel":		"/meta/reconnect",
		"clientId":		"SOME_UNIQUE_CLIENT_ID",
		"timestamp":	"LastReceivedTimeAtServer",
		"id":			"LastReceivedMessageId"
		"connectionId":	"/meta/connections/26",
		"connectionType": "iframe", // FIXME: is this necessaray?
		// optional
		"authToken":	"SOME_NONCE_PREVIOUSLY_PROVIDED_BY_SERVER"
	}

	// and the response looks almost identical to normal
	// preamble/envelope/signoff event delivery except that queued messages may
	// be delivered en-masse. We don't cover it here for the sake of brevity.

	// Subscribing and unsubscribing to channel is straightforward. Subscribing:
	{
		"channel":		"/meta/subscribe",
		"subscription":	"/some/other/channel",
		// optional
		"authToken":	"SOME_NONCE_PREVIOUSLY_PROVIDED_BY_SERVER"
	}

	// response to subscription
	{
		"channel":		"/meta/subscribe",
		"subscription":	"/some/other/channel",
		"successful":	true,
		"error":		"",
		// optional
		"authToken":	"SOME_NONCE"
	}

	// unsubscription for same:
	{
		"channel":		"/meta/unsubscribe",
		"subscription":	"/some/other/channel",
		// optional
		"authToken":	"SOME_NONCE_PREVIOUSLY_PROVIDED_BY_SERVER"
	}

	// and the server response:
	{
		"channel":		"/meta/unsubscribe",
		"subscription":	"/some/other/channel",
		"successful":	true,
		"error":		"",
		// optional
		"authToken":	"SOME_NONCE"
	}

	// FIXME: need to specify the "status" and "ping" message types!!

	// NOTE: the "status" message type may be used for introspection and channel
	// subscription queries

	// NOTE: the "/meta/ping" channel may be safely ignored by servers and
	// clients alike. It may be used as a keepalive mechanism.

	// FIXME: need to build in a provision for batching of queued messages in
	// the returned data structure

NOTE: the 0.1 version of the protocol does NOT acknowledge passing messages
beyond a single router connected to multiple clients. Future protocol versions
may include provisions for this.

NOTE: servers SHOULD maintain event delivery queues for intermittently
disconnected clients. The protocol does not currently specify a way for clients
to specify their per-conection "age limit" nor does it specify a policy for
server event expiration.

TODOC: when subscription happens, it's *clients* that are subscribed, not the
acting tunnels or connections.

FIXME: define globbing semantics
FIXME: extend protocol with acking
FIXME: outline server timeout strategies and why it's not part of the protocol
FIXME: define event ordering
FIXME: provide addendum for to define APIs of conformant JavaScript clients

# vim:ts=4:noet:
