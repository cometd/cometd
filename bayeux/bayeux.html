
<html>
<head>
<style>
body { font-family: san-serif ; margin-left: 25pt;}
h1.title { text-align: center }
h1.intro { text-align: center }
.note{ color: red }

h1,h2,h3,h4 {margin-left: -20pt; margin-bottom: 2pt; }

table.info { width: 100% ;}
pre { margin-left: 25pt; }
dl { margin-left: 25pt; }
dt { font-weight: bold }

</style>
</head>
<body>


<h1 class="title">Dojo Foundation</h1>

<table class="info">
<tr>
<td>
<b>Request for Comments:</b> not an RFC<br/>
<b>Obsoletes:</b> protocol.txt<br/>
<b>Category:</b> Standards Track<br/>
</td>
<td>
Alex Russel<br/>
David Davis<br/>
Greg Wilkins<br/>
</td>
</tr>
</table>

<h1 class="intro">Bayeux Protocol -- Bayeux 0.1draft5</h1>
<h2 class="intro">Status of this Memo</h2>
This document specifies an protocol for the Internet community, and requests discussion and suggestions for improvement. This memo is written in the style and spirit of an RFC but is not, as of yet, an official RFC. Distribution of this memo is unlimited.
This memo is written in UK English.
<p>
<span class="note">This memo is currently incomplete and content has yet to be moved from the protocol.txt file</span>
</p>
<h2 class="intro">Copyright Notice</h2>
Copyright &copy; The Dojo Foundation (2007). All Rights Reserved
<h2 class="intro">Abstract</h2>
<span class="note">
Blurb about what cometd is, about what bayeux is and HTTP and how it is all so difficult and we are all so brilliant for fixing it!   HTTP is client server blah blah....two connection limit blah blah.... cross context dispatch blah blah. imlementation language neutral blah blah
</span>
<h1 class="contents">Table of Contents</h1>
TBD

<h1 class="clause">1. Introduction</h1>
<h2 class="clause">1.1. Purpose</h2>

Bayeux is a protocol for transporting asynchronous messages over HTTP. The messages are routed via named channels and can be delivered: server to client, client to server and client to client (via the server). The primary purpose of Bayeux is to implement Web 2.0 solutions using Ajax and the Ajax push technique called cometd.
Not sure how this differs from the Abstract above... but eitherway some more blurbage should be here.






<h2 class="clause">1.2. Requirements</h2>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC2119. 
An implementation is not compliant if it fails to satisfy one or more of the MUST or REQUIRED level requirements for the protocols it implements. An implementation that satisfies all the MUST or REQUIRED level and all the SHOULD level requirements for its protocols is said to be "unconditionally compliant"; one that satisfies all the MUST level requirements but not all the SHOULD level requirements for its protocols is said to be "conditionally compliant."
<h2 class="clause">1.3. Terminology</h2>


This specification uses a number of terms to refer to the roles played by participants in, and objects of, the Bayeux communication:
<dl>
<dt>client</dt>
<dd>program that establishes connections for the purpose of sending HTTP requests.</dd>
<dt>server</dt>
<dd>An application program that accepts TCP/IP connections in order to service HTTP requests by sending back HTTP responses. </dd>
<dt>request</dt>
<dd>An HTTP request message as defined by section 5 of RFC 2616</dd>
<dt>response</dt>
<dd>A HTTP response message as defined by section 6 of RFC 2616</dd>
<dt>message</dt>
<dd>A message is a JSON object exchanged between client and server for the purposed of implementing the bayeux protocol as defined by section <span class="note">XXX</span></dd>
<dt>event</dt>
<dd>Application specific data that is sent over the bayeux protocol</dd>
<dt>envelope</dt>
<dd>The transport specific message formate that wraps a standard bayeux message.</dd>
<dt>channel</dt>
<dd>A named destination and/or source of events. Events are published to channels and subscribers to channels receive the published events.</dd>
<dt>connection</dt>
<dd><span class="note">blah blah blah</span></dd>
<dt>JSON</dt>
<dd>JavaScript Object Notation is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is described at http://www.json.org/ </dd>
</dl>





<h2 class="clause">1.4. Overall Operation</h2>
<h3 class="clause">1.4.1. HTTP </h3>
The HTTP protocol is a request/response protocol. A client sends a request to the server in the form of a request method, URI, and protocol version, followed by a MIME-like message containing request modifiers, client information, and optional body content over a connection with a server. The server responds with a status line, including the message's protocol version and a success or error code, followed by a MIME-like message containing server information, entity metainformation, and possible entity-body content. 
The server may not initiate a connection with a client nor send an unrequested response to the client, thus asynchronous events cannot be delivered from server to client unless a previously issued request exists. In order to allow two way asynchronous communication, bayeux supports the use of multiple HTTP connections between a client and server, so that previously issued requests are available to transport server to client messages.
The recommendation of section 8.1.4 of RFC 2616 is that a single user client SHOULD NOT maintain more than 2 connection with any server, so XXX
<h3 class="clause">1.4.2. Javascipt</h3>
The majority of Bayeux clients will be implemented in javascript and will be running within the security framework of a client browser.
Say something about x-domain scripting.
<h3 class="clause">1.4.3. Client to Server Event exchange</h3>
A bayeux message is sent from the client to the server via a HTTP request initiated by a user agent and transmitted to an origin server via a chain of zero or more intermediaries (proxy, gateway or tunnel):
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | --M0(E)--> |            |              |            |
 |            | ---HTTP request(M0(E))--> |            |
 |            |            |              | --M0(E)--> |
 |            |            |              | <---M1---- |
 |            | <---HTTP response(M1)---- |            |
 | <---M1---  |            |              |            |
</pre>
The figure above represents a bayeux event E encapsulted in a bayeux message M0 being sent from a bayeux client BC to a bayeux server BS via HTTP request transmitted from a User Agent U to to an Origin server O via a proxy P. The HTTP response contains another bayeux message M1 that will at  contain the protocol response to M0, but may contain other bayeux events initiated on the server or on other clients.
<h3 class="clause">1.4.4. Server to Client Message exchange</h3>
A bayeux message is sent from the server to the client via a HTTP response to a HTTP request  sent in anticipation by a user agent and transmitted to an origin server via a chain of zero or more intermediaries (proxy, gateway or tunnel):
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | --- HTTP request(M0) ---> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E)-- |
 |            | <--HTTP response(M1(E))-- |            |
 | <--M1(E)-- |            |              |            |
 | ---M2--->  |            |              |            |
 |            | --- HTTP request(M2) ---> |            |
 |            |            |              | ----M2---> |
 ~            ~            ~              ~            ~ wait
</pre>
The figure above represents a bayeux message M0 being sent from a bayeux client BC to a bayeux server BS via HTTP request transmitted from a User Agent U to to an Origin server O via a proxy P. The message M0 is sent in anticipation of an bayeux event to be delivered from server to client and the bayeux server waits for such an event before sending a response.  A bayeux event E is shown being delivered via bayeux message M1 in the HTTP response. M1 may contain other bayeux events or an indication that no events were available after a configured timeout. 
On receipt of the HTTP response cotaining M1, the bayeux client issues a new bayeux message M2 in anticipation of more events to be delivered from server to client.
This techique is called long polling.
<h3 class="clause">1.4.5. Streaming transports</h3>
Some bayeux transports use a streaming technique (also called a forever response) that allows multiple messages to be sent over the same HTTP response:

<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | --- HTTP request(M0) ---> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E0)- |
 |            | <--HTTP response(M1(E0))- |            |
 | <--M1(E0)- |            |              |            |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E1)- |
 |            | <----(M1(E1))------------ |            |
 | <--M1(E1)- |            |              |            |
 ~            ~            ~              ~            ~ wait
</pre>
These techiques avoid the latency and extra messaging of anticipatory requests, but is subject to the implementation of user agents and proxies as it requires non complete HTTP responses to be delivered to the bayeux client.
<h3 class="clause">1.4.6. Two connection operation</h3>
In order to operation by-direction communications, a bayeux client will use two HTTP connections to a bayeux server so that both server to client and client to server messaging may occur asynchronously:
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | ------ req0(M0) --------> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 | --M1(E1)-> |            |              |            |
 |            | ----- req1(M1(E1))------> |            |
 |            |            |              | --M1(E1)-> |
 |            |            |              | <---M2---- |
 |            | <---- resp1(M2)---------- |            |
 | <---M2---  |            |              |            |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <-M3(E2)-- |
 |            | <-----resp2(M3(E2))------ |            |
 | <-M3(E2)-- |            |              |            |
 | ---M4--->  |            |              |            |
 |            | ------req3(M4)----------> |            |
 |            |            |              | ----M4---> |
 ~            ~            ~              ~            ~ wait
</pre>
HTTP requests req0 and req1 are sent on different TCP/IP connections, so that the response to req1 may be sent before the response to req0.   Implementations MUST control HTTP pipelining so that req1 does not get queued behind req0 and thus enforce an ordering of responses.
<h3 class="clause">1.4.7. Connection Negotiation</h3>
<span class="note">blah blah blah</span>
<pre class="example">
BC ----------------------------------------- BS
 | ------------------ handshake request ---> |
 | <---- handshake response ---------------- |
 | -------------------- connect request ---> |
 | <---- connect response ------------------ |
 | ------------------ reconnect request ---> |
 ~                                           ~ wait
 | ------------------- message request ----> |
 | <---- message response ------------------ |
 | <---- reconnect response ---------------- |
 </pre>
<h3 class="clause">1.4.8. Unconnected operation</h3>
messages can be sent without a prior handshake....<span class="note">blah blah blah</span>
<pre class="example">
 | ------------------- message request ----> |
 | <---- message response ------------------ |
</pre>






<h1 class="clause">2. Protocol values</h1>
<h2 class="clause">2.1. Common Elements</h2>
The characters used for Bayeux names and identifiers are defined by the BNF definitions:
<pre class="example">
alpha    = lowalpha | upalpha

lowalpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" |
           "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" |
           "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

upalpha  = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" |
           "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" |
           "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"

digit    = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
           "8" | "9"

alphanum = alpha | digit

mark     = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"

reserved = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
           "$" | ","

integer  = digit *( digit )
</pre>


<h2 class="clause">2.2. Channel</h2>
Channels are identified by names that are styled as absolute path component of a URI without parameters as defined by RFC2396.
<pre class="example">
channel_name     = "/"  channel_segments
channel_segments = channel_segment *( "/" channel_segment )
channel_segment  = cchar *cchar
cchar            = alphanum | mark
</pre>
The channel name consists of an initial “/” followed by an optional sequence of path segments separated by a single slash "/" character. Within a path segment, the characters "/", is reserved.
Channel names commencing with "/meta/" are reserved for the use of the protocol. Example channel names are:
<dl>
<dt>/foo</dt>
<dt>/foo/bar</dt>
<dt>/foo-bar/(foobar)</dt>
</dl>

<h3 class="clause">2.2.1 Channel Globbing</h3>
A set of channels may be specified with a channel globbing pattern:
<pre class="example">
channel_pattern  = *( "/" channel_segment ) "/" wild_card
wild_card = "*" | "**"
</pre>
The channel patterns support only trailing wildcards of either "*" to match a single segment or "**" to match multiple segments.
Example channel patterns are:
<dl>
<dt>/foo/*</dt><dd>Matches /foo/bar and /foo/boo. Does not match /foo, /foobar or /foo/bar/boo.</dd>
<dt>/foo/**</dt><dd>Matches /foo/bar, /foo/boo and /foo/bar/boo. Does not match /foo, /foobar or /foobar/boo</dd>
</dl>



<h2 class="clause">2.3. Version</h2>
A protocol version is a integer followed by an optional "." separated sequence of alphanumeric elements:
<pre class="example">
version         = integer *( "." version_element )
version_element = alphanum *( alphanum | "-" | "_" )
</pre>
versions are compared element by element, applying normal alphanumeric comparison to each element.


<h2 class="clause">2.4. Client ID</h2>
A client ID is an random, non predictable sequence of alpha numeric characters:
clientId   =   alphanum *( alphanum )
Client IDs are generated by the server and SHOULD be created with a strong random algorithm that contains at least 128 truly random bits. Servers MUST ensure that client IDs are unique and SHOULD attempt to avoid reuse of client IDs.
<h1 class="clause">3. Messages</h1>
Bayeux messages are JSON encoded objects that contain an unordered sequence of name value pairs representing fields and values. Values may be simple string or numbers or complex JSON encoded objects. bayeux message fields are defined in section [XXX].
A bayeux message MUST contain one and only one channel field [cross reference] . The type of the message is determined by the channel and if the message is sent as part of a request or a response.
All bayeux messages SHOULD be encapsulated in a JSON array, so that multiple messages may be transported together. A bayeux client or servers MUST accept either an array of messages or a single message. The JSON message or array of messages is itself often encapsulated in transport specific formatting and encodings.
Below is an example bayeux message representing an event sent from a client to a server:
<pre class="example">
[
  {
    "channel": "/some/name",
    "clientId": "83js73jsh29sjd92",
    "data": { "myapp" : "specific data", value: 100 }
  }
]
</pre>





<h1 class="clause">4. Message Field Definitions</h1>
<h2 class="clause">4.1. channel</h2>
The channel message field MUST be included in every Bayeux messages to specify source or destination of the message.  In a request, the channel specifies the destination of the message, and for in a response it specifies the source of the message.
<h2 class="clause">4.2. version</h2>
The version message field SHOULD be included in messages to/from the "/meta/handshake" channel to indicate the protocol version expected by the client/server.
<h2 class="clause">4.3. minimumVersion</h2>
The version message field MAY be included in messages from to/from the "/meta/handshake" channel to indicate the oldest protocol version that can be handled by the client/server.
<h2 class="clause">4.4. authScheme</h2>
The authScheme allows the name of an authentication mechanism to be named in a message to the "/meta/handshake" channel. No schemes are currently defined to be supported.
<h2 class="clause">4.5. authUser</h2>
The authUser allows the name of a user to be passed to the authentication mechanism in message to the "/meta/handshake" channel. The format  and validity of the username depends on the authScheme.
<h2 class="clause">4.6. authToken</h2>
The authUser field allows the authentication credentials to be passed to the authentication mechanism in message to the "/meta/handshake" channel. The format  and validity of the username depends on the authScheme.
<h2 class="clause">4.7. supportedConnectionTypes</h2>

The supportedConnectionTypes field is included in messages to and from the "/meta/handshake" channel to allow clients and servers to reveal the transports that are supported. The value is an array of strings, with each string representing a transport name.  Defined connection types include: 
<dl>
<dt>long-polling</dt>
<dd>messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. Messages are sent to the client as unencapsulated body content of a POST response. This transport is defined in section [XXX] of this memo.</dd>
<dt>callback-polling</dt>
<dd>messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. Responses are sent</dd>
<dt>iframe</dt>
<dd><span class="note">buggered if I know</span></dd>
<dt>mime-message-block</dt>
<dd><span class="note">buggered if I know</span></dd>
<dt>flash</dt>
<dd><span class="note">buggered if I know</span></dd>
</dl>

All server and client implementations MUST support the "long-polling" connection type and SHOULD support "callback-polling". All other connection types are OPTIONAL.
<h2 class="clause">4.8. clientId</h2>
<h2 class="clause">4.9. authSuccessful</h2>
<h2 class="clause">4.10. advice</h2>
<p>
The advice field provides a way for servers to inform clients of their
preferred mode of client operation so that in conjunction with server-enforced limits,
Bayeux implementations can prevent resource exhaustion and inelegant failure modes.
</p>
<p>
The advice field is a JSON map containing general and transport specific values that
indicate modes of operation, timeouts and other potentially transport specific parameters.
Defined advice fields are reconnect, interval and multiple-clients.  The reconnect and interval
fields may occur either in the
top level of an advice or within a transport specific section.
</p>
An example advice field is
<pre class="example">

     "advice": { 
        "reconnect": "retry",
        "interval": 1000,
        "iframe" : {
            "reconnect": handshake
         }
     }
</pre>

<h3 class="clause">4.10.1. reconnect</h3>
The reconnection advice field is a string that indicates how the client should act in
the case of a failure to connect or reconnect.  Defined reconnect values are:
<dl>
			<dt>none</dt>
				<dd>hard failure for the connect/reconnect attempt. Do not attempt to
				reconnect at all. </dd>
			<dt>retry</dt>
				<dd>attempt to reconnect again later (as defined by "interval"
				advice or client-default backoff) with the same credentials</dd>
			<dt>handshake</dt>
				<dd>the server doesn't know anything about the client or connection
				that were passed, so instead of attempting to reconnect, throw
				away the client's authentication information and attempt to
				reauthorize with a /meta/handshake</dd>
			<dt>recover</dt>
				<dd>a superset of the "handshake" advice, this tells clients that
				not only should they assume that they need to re-authentiate,
				they also need to resubscribe to all the topics they are
				interested in. This advice may be provided to servers who
				completely fail to locate any matching authentication or
				authorization data regarding the client, e.g. in the case of
				hard failover between a bayeux server and a cold spare.</dd>
</dl>
<h3 class="clause">4.10.2. interval</h3>
An integer representing the period in milliseconds for a client to delay subsequent
attempts of the unsuccessful message. A negative period indicates that the message should
not be retried. 
<h3 class="clause">4.10.2. multiple-clients</h3>
This is a boolean field, which if true indicates that the server has detected multiple bayeux client 
instances running within the same HTTP client.

<h2 class="clause">4.11. connectionType</h2>
<h2 class="clause">4.12. id</h2>
<h2 class="clause">4.13. timestamp</h2>
<h2 class="clause">4.14. data</h2>
<h2 class="clause">4.15. connectionId</h2>
The connectionId field was used during development of the bayeux protocol and it's use is now deprecated.
<h2 class="clause">4.16. successful</h2>
<h2 class="clause">4.17. subscription</h2>
<h2 class="clause">4.18. error</h2>
<h2 class="clause">4.19. ext</h2>
An ext field MAY be included in any bayeux message.  It's value SHOULD be a JSON map with top level names distinguished by implementation names (eg. "org.dojo.bayeux.field").
The contents of ext may be arbitrary values that allow extensions to be negotiated and implemented between implementations.  
<h1 class="clause">5. Meta Message Definitions</h1>
<h2 class="clause">5.1. handshake</h2>
<h3 class="clause">5.1.1. handshake Request</h3>
A bayeux client initiates a connection negotiation by sending a message to the "/meta/handshake" channel. Handshake requests MUST be sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. 
A handshake request MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/handshake"</dd>
<dt>version</dt>
<dd>The version of the protocol supported by the client.</dd>
<dt>supportedConnectionTypes</dt>
<dd>The connection types supported by the client for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type.</dd>
</dl>
A handshake request MAY contain the message fields:
<dl>
<dt>minimumVersion</dt>
<dt>authScheme</dt>
<dt>authUser</dt>
<dt>authToken</dt>
</dl>
A client SHOULD NOT send any other message in the request with a handshake message. A server MUST ignore any other message sent in the same request as a handshake message.
 An example handshake request is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling", "callback-polling", "iframe"],
     "authScheme": "SHA1",
     "authUser": "alex",
     "authToken": "HASHJIBBERISH"
   }
]
</pre>

<h3 class="clause">5.1.2. handshake Response</h3>
A bayeux server MUST respond to a handshake request with a handshake response message in the body content of a  POST response. 
<h4>Successful handshake response</h4>
A successful handshake responses MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/handshake"</dd>
<dt>version</dt><dd></dd>
<dt>supportedConnectionTypes</dt><dd>The connection types supported by the server for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type. This list MUST contain at list one element in common with the supportedConnectionType provided in the handshake request. If there are no connectionTypes in common, the handshake response MUST be unsuccessful.</dd>
<dt>clientId</dt><dd>A newly generated clientId.</dd>
<dt>authSuccessful</dt><dd>value true</dd>
</dl>

A successful handshake responses MAY contain the message fields:
<dl>
<dt>minimumVersion</dt>
<dt>authToken</dt>
<dt>advise</dt>
<dt>ext</dt>
</dl>
An example successful handshake response is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling","callback-polling"],
     "clientId": "Un1q31d3nt1f13r",
     "authSuccessful": true,
     "authToken": "UPDATEDHASHJIBBERISH",
     "advice": { "reconnect": "retry" }
   }
]
</pre>
<h4>Unsuccessful handshake response</h4>
An unsuccessful handshake response MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/handshake"</dd>
<dt>authSuccessful</dt><dd>value false</dd>
<dt>error</dt><dd>a description of the reason for the failure.</dd>
</dl>
An unsuccessful handshake  response MAY contain the message fields:
<dl>
<dt>supportedConnectionTypes</dt><dd>The connection types supported by the server for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type. </dd>
<dt>advice</dt>
<dt>authToken</dt>
<dt>version</dt>
<dt>minimumVersion</dt>
<dt>ext</dt>
</dl>
An example unsuccessful handshake response is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling","callback-polling"],
     "authSuccessful": false,
     "error": "Authentication failed",
     "advice": { "reconnect": "none" }
   }
]
</pre>





<h2 class="clause">5.2. connect</h2>
<h3 class="clause">5.2.1. connect Request</h3>
<p>After a bayeux client has discovered the servers capabilities with a handshake exchange, a connection is established by sending a message to the "/meta/connect" channel. 
This message may be transported over any of the transported indicated as supported by the server in the handshake response.
</p>
A connect request MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/connect"</dd>
<dt>clientId</dt>
<dd>The client ID returned in the handshake response</dd>
<dt>connectionTypes</dt>
<dd>The connection types used by the client for the purposes of this connection.</dd>
</dl>
A connect request MAY contain the message fields:
<dl>
<dt>authToken</dt>
<dt>ext</dt>
</dl>
A client MAY send other messages in the same http request with a connection message. A server MUST handle any other message sent in the same request as a connect message after the handling of the connect message is complete.
An example connect request is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "clientId": "Un1q31d3nt1f13r",
     "connectionType": "long-polling"
   }
]
</pre>

<h3 class="clause">5.2.2. connect Response</h3>

A bayeux server MUST respond to a connect request with a connect response message over the same transport as used for the request.
A bayeux server MUST respond immediately to a connect request.
A bayeux server MAY send event messages for the client in the same http response as the connect response, but the bayeux server MUST NOT 
wait for any such messages before sending the connect response message.
 
A connect responses MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/connect"</dd>
<dt>successful</dt>
<dd>boolean indicating the success or failure of the connection</dd>
<dt>clientId</dt>
<dd>The negotiated client ID</dd>
</dl>
A connect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>ext</dt>
<dt>timestamp</dt>
<dt>connectionId</dt>
</dl>
A successful connect response MAY contain a connectionId message field, but this is deprecated and clients SHOULD ignore this field.
An example connect response is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "successful": true,
     "error": "",
     "clientId": "Un1q31d3nt1f13r",
     "timestamp": "12:00:00 1970",
     "advice": { "reconnect": "retry" }
   }
]
</pre>
Once successfully connected, a client is implicitly subscribed to the channel "/meta/connections/CLIENTID".



<h2 class="clause">5.3. reconnect</h2>
<h3 class="clause">5.3.1. reconnect Request</h3>
<p>
In order to maintain a connection established by a connect message exchange, a beyeux client MUST send a message to the "/meta/reconnect" channel
within the timeouts specificied in the advice received in the handshake or connect response.

The client MUST maintain only a single outstanding reconnect message. If the server does not have a current outstanding reconnect and a reconnect is not 
received within a configured timeout, then the server SHOULD act as if a disconnect message has been received.

The reconnect message MUST be transported over the same transport indicated indicated in the connect request.
</p>
A reconnect requests MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/reconnect"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
</dl>
reconnect requests MAY contain the message fields:
<dl>
<dt>authToken</dt>
<dt>ext</dt>
<dt>connectionType</dt>
</dl>
A client MAY send other messages in the same http request with a reconnect message. A server MUST handle any other message sent in the same request as a reconnect message and 
handling of these messages MUST NOT be defered until a response to the reconnect message is available.
An example reconnect request with an event message is:
<pre class="example">
[
  {
     "channel": "/meta/reconnect",
     "clientId": "Un1q31d3nt1f13r",
     "connectionType": "long-polling"
  },
  {
     "channel": "/some/channel",
     "clientId": "Un1q31d3nt1f13r",
     "data": "some data"
  }
]
</pre>


<h3 class="clause">5.3.2. reconnect Response</h3>
<p>
A bayeux server MUST respond to a reconnect request with a reconnect response message over the same transport as used for the request.
A bayeux server MAY wait to respond until there are event messages available in the subscribed channels for the client that need to be 
delivered to the client. A bayeux server MAY send event messages for the client in the same http response as the connect response.
 </p>
A reconnect responses MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/reconnect"</dd>
<dt>successful</dt><dd>boolean indicating the success or failure of the connection</dd>
</dl>
A reconnect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>ext</dt>
<dt>timestamp</dt>
</dl>
An example reconnect response with an event message is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "successful": true,
     "error": "",
     "timestamp": "12:00:00 1970"
   },
   {
     "channel": "/some/channel",
     "data": "some data"
   }
]
</pre>




<h2 class="clause">5.4. disconnect</h2>
<h3 class="clause">5.4.1. disconnect Request</h3>
<h3 class="clause">5.4.2. disconnect Response</h3>




<h2 class="clause">5.5. status</h2>
<h3 class="clause">5.5.1. status Request</h3>
<h3 class="clause">5.5.2. status Response</h3>




<h2 class="clause">5.6. subscribe</h2>
<h3 class="clause">5.6.1. subscribe Request</h3>
<p>A connected bayeux client may send subscribe messages to register interest in a channel and to request that messages published to the subscribe channel are delivered to the client.
</p>
A subscribe request MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/subscribe"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
<dt>subscription</dt><dd>a channel name or a channel pattern or an array of channel names and channel patterns.</dd>
</dl>
A connect request MAY contain the message fields:
<dl>
<dt>authToken</dt>
<dt>ext</dt>
</dl>
An example subscribe request is:
<pre class="example">
[
  {
     "channel": "/meta/subscribe",
     "clientId": "Un1q31d3nt1f13r",
     "subscription": "/foo/**"
   }
]
</pre>

<h3 class="clause">5.6.2. subscribe Response</h3>
<p>
A bayeux server MUST respond to a subscribe request with a subscribe response message.
A bayeux server MAY send event messages for the client in the same http response as the subscribe response, including events for the channels just subscribed to.
</p>
A subscribe responses MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/subscribe"</dd>
<dt>successful</dt><dd>boolean indicating the success or failure of the connection</dd>
<dt>clientId</dt><dd>The negotiated client ID</dd>
</dl>
A connect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>ext</dt>
<dt>timestamp</dt>
<dt>authToken</dt>
</dl>
An example subscribe response is:
<pre class="example">
[
  {
     "channel": "/meta/subscribe",
     "clientId": "Un1q31d3nt1f13r",
     "subscription": "/foo/**",
     "successful": true,
     "error": ""
   }
]
</pre>





<h2 class="clause">5.7. unsubscribe</h2>
<h3 class="clause">5.7.1. unsubscribe Request</h3>
<h3 class="clause">5.7.2. unsubscribe Response</h3>




<h2 class="clause">5.8. ping</h2>
<h3 class="clause">5.8.1. ping Request</h3>
<h3 class="clause">5.8.2. ping Response</h3>


<h1 class="clause">6. Event Message Definitions</h2>
Application events are published in event messages sent from a bayeux client to a bayeux server and are delivered in event messages sent from a bayeux server to a bayeux client.


<h2 class="clause">6.1. Publish event messages</h2>

<h3 class="clause">5.7.1. publish Request</h3>
<p>
A bayeux client can publish events on a channel by sending an event messages.
An event message MAY be sent in new HTTP request or it MAY be sent in the same HTTP request as 
any message other than a handshake meta message.  
If sent with a connect meta message, the event messages MUST be after the connect message 
and if the connect is unsuccessful, the messages MAY be discarded.
</p>
A publish event message MUST contain the message fields:
<dl>
<dt>channel</dt><dd></dd>
<dt>clientId</dt><dd>The negotiated client ID</dd>
<dt>data</dt><dd>The message as arbitrary JSON object</dd>
</dl>
A connect response MAY contain the message fields:
<dl>
<dt>id</dt><dd>A unique ID for the message generated by the client</dd>
<dt>ext</dt>
<dt>authToken</dt>
</dl>
An example event message is:
<pre class="example">
[
  {
     "channel": "/some/channel",
     "clientId": "Un1q31d3nt1f13r",
     "data": "some application string or JSON object",
     "id": "some unique message id"
  }
]
</pre>



<h3 class="clause">5.7.2. publish Response</h3>
<p>
A bayeux server MAY respond to a publish event message with a publish even acknowlegement.
</p>
A publish event message MUST contain the message fields:
<dl>
<dt>channel</dt><dd></dd>
<dt>clientId</dt><dd>The negotiated client ID</dd>
<dt>successful</dt><dd>boolean indicating the success or otherwise of the publish</dd>
</dl>
A publish event response MAY contain the message fields:
<dl>
<dt>id</dt>
<dt>error</dt>
<dt>ext</dt>
<dt>authToken</dt>
</dl>
An example event message is:
<pre class="example">
[
  {
     "channel": "/some/channel",
     "clientId": "Un1q31d3nt1f13r",
     "data": "some application string or JSON object",
     "id": "some unique message id"
  }
]
</pre>

<p>

<h2 class="clause">6.2. Deliver Event messages</h2>

<p>
Event messages are delivered to clients if the client is subscribed to the channel of the event message.
Event messages may be sent to the client in the same HTTP response as any other message other than a meta handshake response.
If a bayeux server has multiple HTTP requests from the same client, the server SHOULD deliver all available messages in HTTP response 
that will be sent immediately in preference to waking a waiting reconnect meta message handler.
Event message deliver is not acknowlegded by the client.
</p>

<p>
A deliver event message MUST contain the message fields:
</p>
<dl>
<dt>channel</dt><dd></dd>
<dt>data</dt><dd>The message as arbitrary JSON object</dd>
</dl>
A publish event response MAY contain the message fields:
<dl>
<dt>id</dt><dd>Unique message ID from the publisher</dd>
<dt>clientId</dt><dd>The client ID of the publisher</dd>
<dt>ext</dt>
<dt>authToken</dt>
<dt>advice</dt>
</dl>
An example event deliver message is:
<pre class="example">
[
  {
     "channel": "/some/channel",
     "data": "some application string or JSON object",
     "id": "some unique message id"
  }
]
</pre>



<h1 class="clause">7. Transports</h1>
<h2 class="clause">7.1. long-polling</h2>
messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. 
Messages are sent to the client as unencapsulated body content of a POST response. 
<span class="note">Should we support commented json to protect against hijacking</span>
<h2 class="clause">7.2. callback-polling</h2>
<h2 class="clause">7.3. iframe</h2>
<h1 class="clause">8. Security</h1>
<span class="note">Need examples of how auth tokens and credentials can be used.</span>
<span class="note">Need examples of how authSuccess=false and advice in handshake can be used to do challenge response stuff</span>

<h2 class="clause">8.1. Ajax Hijacking</h2>
<p>
The Ajax hijacking vulnerability is when an attacking web site uses a script tag to execute JSON content obtained from an Ajax server. The Bayeux protocol is 
not vulnerable to this style of attack as cookies are not used for authentication and a valid client ID is needed before private client data is returned.  The use of POST requests
further protects against this style of attack.  
</p>
<p>
To futher protect against this class of attack, it is RECOMMEDED that Bayeux clients and servers support json comment filtered format, where the outer JSON array is enclosed in
a comment that will prevent execution of the JSON without explicit handling of the comment characters. An example of a commented message is:</p>
<pre class="example">
/*[
  {
     "channel": "/some/channel",
     "data": "some application string or JSON object",
     "id": "some unique message id"
  }
]*/
</pre>
<p>An extension field of json-comment-filtered should be sent by client and server to indicate that comment-filtering is supported. 
If it is, the content-type should be text/json-comment-filtered.
</p>

<h1 class="clause">9. Multi frame operation</h1>
<p>Current HTTP client implementations are RECOMMENDED to allow only two connections between a client and a server.  This presents a problem when multiple instances of the bayeux client are operating
in multiple tabs or windows of the same browser instance.   The two connection limit can be consumed by outstanding reconnect meta messages from each tab or window and thus prevent 
other messages from being delivered in a timely fashion.
</p>

<h2 class="clause">9.1 Server Multi frame detection</h2>
<p>
It is RECOMMENDED that bayeux server implementations use the cookie "BAYEUX_HTTP_ID" to identify a HTTP client and to thus detect multiple bayeux clients running within the same HTTP
client.  Once detected, the server SHOULD not wait for messages in reconnect and SHOULD use the advice interval mechanism to establish traditional polling.
</p>

<h2 class="clause">9.1 Client Multi frame handling</h2>
<p>
It is RECOMMENDED that bayeux client implementations use the client side persistence or cookies to detect multiple intances of bayeux clients running within the same HTTP client.
Once detected, the user MAY be offerred the option to disconnect all but one of the clients.  It MAY be possible for client implementations to use client side persistence to 
share a bayeux client instance. 
</p>




