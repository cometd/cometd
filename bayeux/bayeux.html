<html>
<head>
<style>
body { font-family: san-serif ; margin-left: 25pt;}
h1.title { text-align: center }
h1.intro { text-align: center }
.note{ color: red }

h1,h2,h3,h4 {margin-left: -20pt; margin-bottom: 2pt; }

table.info { width: 100% ;}
pre { margin-left: 25pt; }
dl { margin-left: 25pt; }
dt { font-weight: bold }

</style>
</head>
<body>


<h1 class="title">Dojo Foundation</h1>

<table class="info">
<tr>
<td>
<b>Request for Comments:</b> not an RFC<br/>
<b>Obsoletes:</b> protocol.txt<br/>
<b>Category:</b> Standards Track<br/>
</td>
<td>
Alex Russel<br/>
David Davis<br/>
Greg Wilkins<br/>
Mark Nesbitt<br/>
</td>
</tr>
</table>

<h1 class="intro">Bayeux Protocol -- Bayeux 0.1draft5</h1>
<h2 class="intro">Status of this Memo</h2>
This document specifies an protocol for the Internet community, and requests discussion and suggestions for improvement. This memo is written in the style and spirit of an RFC but is not, as of yet, an official RFC. Distribution of this memo is unlimited.
This memo is written in UK English.
<p>
<span class="note">This memo is currently incomplete and content has yet to be moved from the protocol.txt file</span>
</p>
<h2 class="intro">Copyright Notice</h2>
Copyright &copy; The Dojo Foundation (2007). All Rights Reserved
<h2 class="intro">Abstract</h2>
<span class="note">
Blurb about what cometd is, about what bayeux is and HTTP and how it is all so difficult and we are all so brilliant for fixing it!   HTTP is client server blah blah....two connection limit blah blah.... cross context dispatch blah blah. imlementation language neutral blah blah
</span>
<h1 class="contents">Table of Contents</h1>
TBD

<h1 class="clause">1. Introduction</h1>
<h2 class="clause">1.1. Purpose</h2>

Bayeux is a protocol for transporting asynchronous messages over HTTP. The messages are routed via named channels and can be delivered: server to client, client to server and client to client (via the server). The primary purpose of Bayeux is to implement Web 2.0 solutions using Ajax and the Ajax push technique called cometd.
Not sure how this differs from the Abstract above... but eitherway some more blurbage should be here.






<h2 class="clause">1.2. Requirements</h2>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC2119. 
An implementation is not compliant if it fails to satisfy one or more of the MUST or REQUIRED level requirements for the protocols it implements. An implementation that satisfies all the MUST or REQUIRED level and all the SHOULD level requirements for its protocols is said to be "unconditionally compliant"; one that satisfies all the MUST level requirements but not all the SHOULD level requirements for its protocols is said to be "conditionally compliant."
<h2 class="clause">1.3. Terminology</h2>


This specification uses a number of terms to refer to the roles played by participants in, and objects of, the Bayeux communication:
<dl>
<dt>client</dt>
<dd>program that establishes connections for the purpose of sending HTTP requests.</dd>
<dt>server</dt>
<dd>An application program that accepts TCP/IP connections in order to service HTTP requests by sending back HTTP responses. </dd>
<dt>request</dt>
<dd>An HTTP request message as defined by section 5 of RFC 2616</dd>
<dt>response</dt>
<dd>A HTTP response message as defined by section 6 of RFC 2616</dd>
<dt>message</dt>
<dd>A message is a JSON object exchanged between client and server for the purposed of implementing the bayeux protocol as defined by section <span class="note">XXX</span></dd>
<dt>event</dt>
<dd>Application specific data that is sent over the bayeux protocol</dd>
<dt>envelope</dt>
<dd>The transport specific message formate that wraps a standard bayeux message.</dd>
<dt>channel</dt>
<dd>A named destination and/or source of events. Events are published to channels and subscribers to channels receive the published events.</dd>
<dt>connection</dt>
<dd><span class="note">blah blah blah</span></dd>
<dt>JSON</dt>
<dd>JavaScript Object Notation is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is described at http://www.json.org/ </dd>
</dl>





<h2 class="clause">1.4. Overall Operation</h2>
<h3 class="clause">1.4.1. HTTP </h3>
The HTTP protocol is a request/response protocol. A client sends a request to the server in the form of a request method, URI, and protocol version, followed by a MIME-like message containing request modifiers, client information, and optional body content over a connection with a server. The server responds with a status line, including the message's protocol version and a success or error code, followed by a MIME-like message containing server information, entity metainformation, and possible entity-body content. 
The server may not initiate a connection with a client nor send an unrequested response to the client, thus asynchronous events cannot be delivered from server to client unless a previously issued request exists. In order to allow two way asynchronous communication, bayeux supports the use of multiple HTTP connections between a client and server, so that previously issued requests are available to transport server to client messages.
The recommendation of section 8.1.4 of RFC 2616 is that a single user client SHOULD NOT maintain more than 2 connection with any server, so XXX
<h3 class="clause">1.4.2. Javascipt</h3>
The majority of Bayeux clients will be implemented in javascript and will be running within the security framework of a client browser.
Say something about x-domain scripting.
<h3 class="clause">1.4.3. Client to Server Event exchange</h3>
A bayeux message is sent from the client to the server via a HTTP request initiated by a user agent and transmitted to an origin server via a chain of zero or more intermediaries (proxy, gateway or tunnel):
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | --M0(E)--> |            |              |            |
 |            | ---HTTP request(M0(E))--> |            |
 |            |            |              | --M0(E)--> |
 |            |            |              | <---M1---- |
 |            | <---HTTP response(M1)---- |            |
 | <---M1---  |            |              |            |
</pre>
The figure above represents a bayeux event E encapsulted in a bayeux message M0 being sent from a bayeux client BC to a bayeux server BS via HTTP request transmitted from a User Agent U to to an Origin server O via a proxy P. The HTTP response contains another bayeux message M1 that will at  contain the protocol response to M0, but may contain other bayeux events initiated on the server or on other clients.
<h3 class="clause">1.4.4. Server to Client Message exchange</h3>
A bayeux message is sent from the server to the client via a HTTP response to a HTTP request  sent in anticipation by a user agent and transmitted to an origin server via a chain of zero or more intermediaries (proxy, gateway or tunnel):
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | --- HTTP request(M0) ---> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E)-- |
 |            | <--HTTP response(M1(E))-- |            |
 | <--M1(E)-- |            |              |            |
 | ---M2--->  |            |              |            |
 |            | --- HTTP request(M2) ---> |            |
 |            |            |              | ----M2---> |
 ~            ~            ~              ~            ~ wait
</pre>
The figure above represents a bayeux message M0 being sent from a bayeux client BC to a bayeux server BS via HTTP request transmitted from a User Agent U to to an Origin server O via a proxy P. The message M0 is sent in anticipation of an bayeux event to be delivered from server to client and the bayeux server waits for such an event before sending a response.  A bayeux event E is shown being delivered via bayeux message M1 in the HTTP response. M1 may contain other bayeux events or an indication that no events were available after a configured timeout. 
On receipt of the HTTP response cotaining M1, the bayeux client issues a new bayeux message M2 in anticipation of more events to be delivered from server to client.
This techique is called long polling.
<h3 class="clause">1.4.5. Streaming transports</h3>
Some bayeux transports use a streaming technique (also called a forever response) that allows multiple messages to be sent over the same HTTP response:

<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | --- HTTP request(M0) ---> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E0)- |
 |            | <--HTTP response(M1(E0))- |            |
 | <--M1(E0)- |            |              |            |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E1)- |
 |            | <----(M1(E1))------------ |            |
 | <--M1(E1)- |            |              |            |
 ~            ~            ~              ~            ~ wait
</pre>
These techiques avoid the latency and extra messaging of anticipatory requests, but is subject to the implementation of user agents and proxies as it requires non complete HTTP responses to be delivered to the bayeux client.
<h3 class="clause">1.4.6. Two connection operation</h3>
In order to operation by-direction communications, a bayeux client will use two HTTP connections to a bayeux server so that both server to client and client to server messaging may occur asynchronously:
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | ------ req0(M0) --------> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 | --M1(E1)-> |            |              |            |
 |            | ----- req1(M1(E1))------> |            |
 |            |            |              | --M1(E1)-> |
 |            |            |              | <---M2---- |
 |            | <---- resp1(M2)---------- |            |
 | <---M2---  |            |              |            |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <-M3(E2)-- |
 |            | <-----resp2(M3(E2))------ |            |
 | <-M3(E2)-- |            |              |            |
 | ---M4--->  |            |              |            |
 |            | ------req3(M4)----------> |            |
 |            |            |              | ----M4---> |
 ~            ~            ~              ~            ~ wait
</pre>
HTTP requests req0 and req1 are sent on different TCP/IP connections, so that the response to req1 may be sent before the response to req0.   Implementations MUST control HTTP pipelining so that req1 does not get queued behind req0 and thus enforce an ordering of responses.
<h3 class="clause">1.4.7. Connection Negotiation</h3>
<p>
Bayeux connections are negotiated between client and server with handshake messages that allow
the connection type, authentication and other parameters to be agreed between the client and the
server.
</p>
<pre class="example">
BC ----------------------------------------- BS
 | ------------------ handshake request ---> |
 | <---- handshake response ---------------- |
 | -------------------- connect request ---> |
 | <---- connect response ------------------ |
 | ------------------ reconnect request ---> |
 ~                                           ~ wait
 | <---- reconnect response ---------------- |
 </pre>
<p>
Connection negotiation may be iterative and several
handshake messages may be exchanged before a successful
connection is obtained.   Servers may also request
that connections is renegotiated by sending an
unsuccessful reconnect response with advice to reconnect
with a handshake message.
</p>
<pre class="example">
BC ----------------------------------------- BS
 | ------------------ handshake request ---> |
 | <-- unsuccessful handshake response ----- |
 | ------------------ handshake request ---> |
 | <-- successful handshake response ------- |
 | -------------------- connect request ---> |
 | <---- connect response ------------------ |
 | ------------------ reconnect request ---> |
 ~                                           ~ wait
 | <---- reconnect response ---------------- |
 | ------------------ reconnect request ---> |
 | <---- unsucessful reconnect response ---- |
 | ------------------ handshake request ---> |
 | <-- successful handshake response ------- |
 | -------------------- connect request ---> |
 | <---- connect response ------------------ |
 | ------------------ reconnect request ---> |
 ~                                           ~ wait
 | <---- reconnect response ---------------- |
 </pre>




<h3 class="clause">1.4.8. Unconnected operation</h3>
messages can be sent without a prior handshake....<span class="note">blah blah blah</span>
<pre class="example">
 | ------------------- message request ----> |
 | <---- message response ------------------ |
</pre>






<h1 class="clause">2. Protocol values</h1>
<h2 class="clause">2.1. Common Elements</h2>
The characters used for Bayeux names and identifiers are defined by the BNF definitions:
<pre class="example">
alpha    = lowalpha | upalpha

lowalpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" |
           "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" |
           "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

upalpha  = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" |
           "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" |
           "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"

digit    = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
           "8" | "9"

alphanum = alpha | digit

mark     = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"

reserved = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
           "$" | ","

integer  = digit *( digit )
</pre>


<h2 class="clause">2.2. Channel</h2>
Channels are identified by names that are styled as absolute path component of a URI without parameters as defined by RFC2396.
<pre class="example">
channel_name     = "/"  channel_segments
channel_segments = channel_segment *( "/" channel_segment )
channel_segment  = cchar *cchar
cchar            = alphanum | mark
</pre>
The channel name consists of an initial ‚Äú/‚Äù followed by an optional sequence of path segments separated by a single slash "/" character. Within a path segment, the characters "/", is reserved.
Channel names commencing with "/meta/" are reserved for the use of the protocol. Example channel names are:
<dl>
<dt>/foo</dt>
<dt>/foo/bar</dt>
<dt>/foo-bar/(foobar)</dt>
</dl>

<h3 class="clause">2.2.1 Channel Globbing</h3>
A set of channels may be specified with a channel globbing pattern:
<pre class="example">
channel_pattern  = *( "/" channel_segment ) "/" wild_card
wild_card = "*" | "**"
</pre>
The channel patterns support only trailing wildcards of either "*" to match a single segment or "**" to match multiple segments.
Example channel patterns are:
<dl>
<dt>/foo/*</dt><dd>Matches /foo/bar and /foo/boo. Does not match /foo, /foobar or /foo/bar/boo.</dd>
<dt>/foo/**</dt><dd>Matches /foo/bar, /foo/boo and /foo/bar/boo. Does not match /foo, /foobar or /foobar/boo</dd>
</dl>



<h2 class="clause">2.3. Version</h2>
A protocol version is a integer followed by an optional "." separated sequence of alphanumeric elements:
<pre class="example">
version         = integer *( "." version_element )
version_element = alphanum *( alphanum | "-" | "_" )
</pre>
versions are compared element by element, applying normal alphanumeric comparison to each element.


<h2 class="clause">2.4. Client ID</h2>
A client ID is an random, non predictable sequence of alpha numeric characters:
clientId   =   alphanum *( alphanum )
Client IDs are generated by the server and SHOULD be created with a strong random algorithm that contains at least 128 truly random bits. Servers MUST ensure that client IDs are unique and SHOULD attempt to avoid reuse of client IDs.
<h1 class="clause">3. Messages</h1>
Bayeux messages are JSON encoded objects that contain an unordered sequence of name value pairs representing fields and values. Values may be simple string or numbers or complex JSON encoded objects. bayeux message fields are defined in section [XXX].
A bayeux message MUST contain one and only one channel field [cross reference] . The type of the message is determined by the channel and if the message is sent as part of a request or a response.
All bayeux messages SHOULD be encapsulated in a JSON array, so that multiple messages may be transported together. A bayeux client or server MUST accept either an array of messages or a single message. The JSON message or array of messages is itself often encapsulated in transport specific formatting and encodings.
Below is an example bayeux message representing an event sent from a client to a server:
<pre class="example">
[
  {
    "channel": "/some/name",
    "clientId": "83js73jsh29sjd92",
    "data": { "myapp" : "specific data", value: 100 }
  }
]
</pre>





<h1 class="clause">4. Message Field Definitions</h1>
<h2 class="clause">4.1. channel</h2>
The channel message field MUST be included in every Bayeux message to specify source or destination of the message.  In a request, the channel specifies the destination of the message, and in a response it specifies the source of the message.
<h2 class="clause">4.2. version</h2>
The version message field SHOULD be included in messages to/from the "/meta/handshake" channel to indicate the protocol version expected by the client/server.
<h2 class="clause">4.3. minimumVersion</h2>
The minimumVersion message field MAY be included in messages from to/from the "/meta/handshake" channel to indicate the oldest protocol version that can be handled by the client/server.
<h2 class="clause">4.4. authScheme</h2>
Deprecated field no longer supported.
<h2 class="clause">4.5. authUser</h2>
Deprecated field no longer supported.
<h2 class="clause">4.6. authToken</h2>
Deprecated field no longer supported.
<h2 class="clause">4.7. supportedConnectionTypes</h2>

The supportedConnectionTypes field is included in messages to and from the "/meta/handshake" channel to allow clients and servers to reveal the transports that are supported. The value is an array of strings, with each string representing a transport name.  Defined connection types include: 
<dl>
<dt>long-polling</dt>
<dd>messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. Messages are sent to the client as unencapsulated body content of a POST response. This transport is defined in section [XXX] of this memo.</dd>
<dt>callback-polling</dt>
<dd>messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. Responses are sent</dd>
<dt>iframe</dt>
<dd><span class="note">buggered if I know</span></dd>
<dt>mime-message-block</dt>
<dd><span class="note">buggered if I know</span></dd>
<dt>flash</dt>
<dd><span class="note">buggered if I know</span></dd>
</dl>

All server and client implementations MUST support the "long-polling" connection type and SHOULD support "callback-polling". All other connection types are OPTIONAL.
<h2 class="clause">4.8. clientId</h2>
The clientId message field uniquely identifies a client to a Bayeux server.   The clientId message field MUST be 
included in every message sent to the server except for a message sent to the "/meta/handshake" channel.   The clientId field will be returned in every message
 response except for a failed handshake request and is OPTIONAL in a message delivery message.    
<h2 class="clause">4.9. advice</h2>
<p>
The advice field provides a way for servers to inform clients of their
preferred mode of client operation so that in conjunction with server-enforced limits,
Bayeux implementations can prevent resource exhaustion and inelegant failure modes.
</p>
<p>
The advice field is a JSON map containing general and transport specific values that
indicate modes of operation, timeouts and other potential transport specific parameters.
Fields may occur either in the top level of an advice or within a transport specific section.
</p>
<p>
Unless otherwise specified in sections 5 and 6, any Bayeux response message may contain an advice
field.  Advice received always superceeds any previous received advice.
</p>
An example advice field is
<pre class="example">

     "advice": { 
        "reconnect": "retry",
        "interval": 1000,
        "callback-polling" : {
            "reconnect": "handshake"
         }
     }
</pre>

<h3 class="clause">4.9.1. reconnect</h3>
The reconnection advice field is a string that indicates how the client should act in
the case of a failure to connect or reconnect.  Defined reconnect values are:
<dl>
			<dt>none</dt>
				<dd>hard failure for the connect/reconnect attempt. Do not attempt to
				reconnect at all. </dd>
			<dt>retry</dt>
				<dd>attempt to reconnect again later (as defined by "interval"
				advice or client-default backoff) with the same credentials</dd>
			<dt>handshake</dt>
				<dd>the server doesn't know anything about the client or connection
				that were passed, so instead of attempting to reconnect, throw
				away the client's authentication information and attempt to
				reauthorize with a /meta/handshake</dd>
			<dt>recover</dt>
				<dd>a superset of the "handshake" advice, this tells clients that
				not only should they assume that they need to re-authentiate,
				they also need to resubscribe to all the topics they are
				interested in. This advice may be provided to servers who
				completely fail to locate any matching authentication or
				authorization data regarding the client, e.g. in the case of
				hard failover between a bayeux server and a cold spare.</dd>
</dl>
<h3 class="clause">4.9.2. interval</h3>
An integer representing the period in milliseconds for a client to delay subsequent
attempts of the unsuccessful message. A negative period indicates that the message should
not be retried. 
<h3 class="clause">4.9.3. multiple-clients</h3>
This is a boolean field, which if true indicates that the server has detected multiple bayeux client 
instances running within the same HTTP client.
<h3 class="clause">4.9.4. hosts</h3>
This is an array of strings field, which if present indicates a list of host names or IP addresses
that MAY be used as alternate servers with which the client may connect.  If a client receives
advice to re handshake an the current server is not included in a supplied hosts list, then the
client SHOULD try the hosts in order until a successful connection is establish. Advice received
during handshakes with hosts in the list supercedes any previously received advice.

<h2 class="clause">4.10. connectionType</h2>
The connectionType message field specifies the type of transport the client requires for communication.   The connectionType message
 field MUST be included in requests to the "/meta/connect" channel and is OPTIONAL in requests to the "/meta/reconnect" channel.
  Connection types are defined in section 4.7.   
<h2 class="clause">4.11. id</h2>
The id message is field used to identify event messages.   An id message MAY be included in publish requests or in a requests to the "meta/reconnect" channel.  The id message field
MAY be included in a response to a publish request and in an event delivery message.
<h2 class="clause">4.12. timestamp</h2>
The timestamp message field SHOULD be specified in the following ISO 8601 profile:  All times SHOULD be sent in GMT time.
<pre class="example">
   YYYY-MM-DDThh:mm:ss.ss
</pre>
A timestamp message is OPTIONAL in a bayeux server response to the "/meta/connect", "/meta/reconnect", "/meta/subscribe", "/meta/unsubscribe", publish, and event delivery channels.
 A timestamp message is OPTIONAL  in a bayeux reconnect request.

<h2 class="clause">4.13. data</h2>
The data message field is an arbitrary JSON object that contains event information.  The data field MUST be included in publish requests, and a Bayeux server MUST include
the data field in an event delivery message. 
<h2 class="clause">4.14. connectionId</h2>
The connectionId field was used during development of the bayeux protocol and it's use is now deprecated.
<h2 class="clause">4.15. successful</h2>
The successful boolean message field is used indicate success or failure and MUST be included in responses to the "/meta/handshake", "/meta/connect",
 "/meta/reconnect", "/meta/subscribe","/meta/unsubscribe", "/meta/disconnect", and publish channels.  
<h2 class="clause">4.16. subscription</h2>
The subscription message field specific the channels the client wishes to subscribe to or unsubscribe from. The subscription message field MUST
 be included in requests and responses to/from the "/meta/subscribe" or "/meta/unsubscribe" channels. 
<h2 class="clause">4.17. error</h2>
The error message field is OPTIONAL on any bayeux response.  The error message field MAY indicate the type of error that occurred when a request returns with a false successful message. The error message field should be sent in string format.
   This version of the protocol does not define any standard messages.  It is up to the server implementation to define error messages and provide 
support for message localization on the client.
<h2 class="clause">4.17. ext</h2>
An ext field MAY be included in any bayeux message.  It's value SHOULD be a JSON map with top level names distinguished by implementation names (eg. "org.dojo.bayeux.field").
The contents of ext may be arbitrary values that allow extensions to be negotiated and implemented between implementations.  
<h1 class="clause">5. Meta Message Definitions</h1>
<h2 class="clause">5.1. handshake</h2>
<h3 class="clause">5.1.1. handshake Request</h3>
A bayeux client initiates a connection negotiation by sending a message to the "/meta/handshake" channel. Handshake requests MUST be sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. 
A handshake request MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/handshake"</dd>
<dt>version</dt>
<dd>The version of the protocol supported by the client.</dd>
<dt>supportedConnectionTypes</dt>
<dd>The connection types supported by the client for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type.</dd>
</dl>
A handshake request MAY contain the message fields:
<dl>
<dt>minimumVersion</dt>
<dt>ext</dt>
</dl>
A client SHOULD NOT send any other message in the request with a handshake message. A server MUST ignore any other message sent in the same request as a handshake message.
 An example handshake request is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling", "callback-polling", "iframe"],
   }
]
</pre>

<h3 class="clause">5.1.2. handshake Response</h3>
A bayeux server MUST respond to a handshake request with a handshake response message in the body content of a  POST response. 
<h4>Successful handshake response</h4>
A successful handshake responses MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/handshake"</dd>
<dt>version</dt><dd></dd>
<dt>supportedConnectionTypes</dt><dd>The connection types supported by the server for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type. This list MUST contain at list one element in common with the supportedConnectionType provided in the handshake request. If there are no connectionTypes in common, the handshake response MUST be unsuccessful.</dd>
<dt>clientId</dt><dd>A newly generated clientId.</dd>
<dt>successful</dt><dd>value true</dd>
</dl>

A successful handshake responses MAY contain the message fields:
<dl>
<dt>minimumVersion</dt>
<dt>advise</dt>
<dt>ext</dt>
<dt>authSuccessful</dt><dd>Value true, this field may be included to support
prototype client implementations that required the authSuccessful field</dd>
</dl>    
An example successful handshake response is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling","callback-polling"],
     "clientId": "Un1q31d3nt1f13r",
     "successful": true,
     "authSuccessful": true,
     "advice": { "reconnect": "retry" }
   }
]
</pre>
<h4>Unsuccessful handshake response</h4>
An unsuccessful handshake response MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/handshake"</dd>
<dt>successful</dt><dd>value false</dd>
<dt>error</dt><dd>a description of the reason for the failure.</dd>
</dl>
An unsuccessful handshake  response MAY contain the message fields:
<dl>
<dt>supportedConnectionTypes</dt><dd>The connection types supported by the server for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type. </dd>
<dt>advice</dt>
<dt>version</dt>
<dt>minimumVersion</dt>
<dt>ext</dt>
</dl>
An example unsuccessful handshake response is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling","callback-polling"],
     "successful": false,
     "error": "Authentication failed",
     "advice": { "reconnect": "none" }
   }
]
</pre>

<p>
For complex connection negotiations, multiple handshake messages may be exchanged between the
bayeux client and server.  The handshake response will be unsuccessful until the handshake processs
is complete. The advice and ext fields may be used to communicate additional information needed to
complete the handshake process. An unsuccessful handshake response with reconnect advice of
"handshake" is used to continue the connection negotiation.  An unsuccessful handshake response
with reconnect advice of "none" is used to terminate connection negotiations.
</p>




<h2 class="clause">5.2. connect</h2>
<h3 class="clause">5.2.1. connect Request</h3>
<p>After a bayeux client has discovered the servers capabilities with a handshake exchange, a connection is established by sending a message to the "/meta/connect" channel. 
This message may be transported over any of the transported indicated as supported by the server in the handshake response.
</p>
A connect request MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/connect"</dd>
<dt>clientId</dt>
<dd>The client ID returned in the handshake response</dd>
<dt>connectionTypes</dt>
<dd>The connection types used by the client for the purposes of this connection.</dd>
</dl>
A connect request MAY contain the message fields:
<dl>
<dt>ext</dt>
</dl>
A client MAY send other messages in the same http request with a connection message. A server MUST handle any other message sent in the same request as a connect message after the handling of the connect message is complete.
An example connect request is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "clientId": "Un1q31d3nt1f13r",
     "connectionType": "long-polling"
   }
]
</pre>

<h3 class="clause">5.2.2. connect Response</h3>

A bayeux server MUST respond to a connect request with a connect response message over the same transport as used for the request.
A bayeux server MUST respond immediately to a connect request.
A bayeux server MAY send event messages for the client in the same http response as the connect response, but the bayeux server MUST NOT 
wait for any such messages before sending the connect response message.
 
A connect responses MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/connect"</dd>
<dt>successful</dt>
<dd>boolean indicating the success or failure of the connection</dd>
<dt>clientId</dt>
<dd>The negotiated client ID</dd>
</dl>
A connect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>ext</dt>
<dt>timestamp</dt>
<dt>connectionId</dt>
</dl>
A successful connect response MAY contain a connectionId message field, but this is deprecated and clients SHOULD ignore this field.
An example connect response is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "successful": true,
     "error": "",
     "clientId": "Un1q31d3nt1f13r",
     "timestamp": "12:00:00 1970",
     "advice": { "reconnect": "retry" }
   }
]
</pre>
Once successfully connected, a client is implicitly subscribed to the channel "/meta/connections/CLIENTID".



<h2 class="clause">5.3. reconnect</h2>
<h3 class="clause">5.3.1. reconnect Request</h3>
<p>
In order to maintain a connection established by a connect message exchange, a beyeux client MUST send a message to the "/meta/reconnect" channel
within the timeouts specificied in the advice received in the handshake or connect response.

The client MUST maintain only a single outstanding reconnect message. If the server does not have a current outstanding reconnect and a reconnect is not 
received within a configured timeout, then the server SHOULD act as if a disconnect message has been received.

The reconnect message MUST be transported over the same transport indicated indicated in the connect request.
</p>
A reconnect requests MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/reconnect"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
</dl>
reconnect requests MAY contain the message fields:
<dl>
<dt>ext</dt>
<dt>connectionType</dt>
</dl>
A client MAY send other messages in the same http request with a reconnect message. A server MUST handle any other message sent in the same request as a reconnect message and 
handling of these messages MUST NOT be defered until a response to the reconnect message is available.
An example reconnect request with an event message is:
<pre class="example">
[
  {
     "channel": "/meta/reconnect",
     "clientId": "Un1q31d3nt1f13r",
     "connectionType": "long-polling"
  },
  {
     "channel": "/some/channel",
     "clientId": "Un1q31d3nt1f13r",
     "data": "some data"
  }
]
</pre>


<h3 class="clause">5.3.2. reconnect Response</h3>
<p>
A bayeux server MUST respond to a reconnect request with a reconnect response message over the same transport as used for the request.
A bayeux server MAY wait to respond until there are event messages available in the subscribed channels for the client that need to be 
delivered to the client. A bayeux server MAY send event messages for the client in the same http response as the connect response.
 </p>
A reconnect responses MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/reconnect"</dd>
<dt>successful</dt><dd>boolean indicating the success or failure of the connection</dd>
</dl>
A reconnect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>ext</dt>
<dt>timestamp</dt>
</dl>
An example reconnect response with an event message is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "successful": true,
     "error": "",
     "timestamp": "12:00:00 1970"
   },
   {
     "channel": "/some/channel",
     "data": "some data"
   }
]
</pre>




<h2 class="clause">5.4. disconnect</h2>
<h3 class="clause">5.4.1. disconnect Request</h3>
<p>
When a connected client wishes to cease operation it should send a request to the "/meta/disconnect" channel for the server to remove any client state.  The server SHOULD release any waiting meta message handlers.   Bayeux client applications should send a disconnect request when the user shuts down a browser window or leaves the current page. A Bayeux server SHOULD  not rely solely on the client sending a disconnect message to remove client state information because a disconnect message might not be sent from the client or the disconnect request might not reach the server.
</p>
A disconnect request MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/disconnect"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
</dl>
A disconnect request MAY contain the message fields:
<dl>
<dt>ext</dt>
</dl>
An example disconnect request is:
<pre class="example">
[
  {
     "channel": "/meta/disconnect",
     "clientId": "Un1q31d3nt1f13r"
   }
]
</pre>
<h3 class="clause">5.4.2. disconnect Response</h3>
<p>
A bayeux server must respond to a disconnect request with a disconnect response.   
A disconnect response MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/disconnect"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
<dt>successful</dt><dd>boolean value indicated the success or failure of the disconnect request</dd>
</dl>
A disconnect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>ext</dt>
</dl>
An example disconnect response is:
<pre class="example">
[
  {
     "channel": "/meta/disconnect",
     "clientId": "Un1q31d3nt1f13r",
     "subscription": true 
   }
]
</pre>




<h2 class="clause">5.5. status</h2>
<h3 class="clause">5.5.1. status Request</h3>
<div style="color:red"><b> THIS SECTION IS TEMPORARY AND SUBJECT TO REMOVAL</b></div>
<p>
 A connected bayeux client may send a status request to receive information such as a list of server topics, a list of topics subscribed to,
 or other information.  Server implementation of the "/meta/status" channel is OPTIONAL and server dependent.   This version of the protocol 
 does not specify how to request this information or how to respond to status requests.   The ext advanced field should be used to request 
 status information and read status information replies.  
</p>
  A status request must contain the follow fields
<dl>
<dt>channel</dt><dd>value "/meta/status"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
</dl>
A status request MAY contain the message fields:
<dl>
<dt>ext</dt><dd>This field is server dependent indicator typically used to indicate type of status requested.
</dl>
An example status request is:
<pre class="example">
[
  {
     "channel": "/meta/status",
     "clientId": "Un1q31d3nt1f13rî,
     "ext":  {"org.dojo.bayeux.status": {"serverTopics"} }
   }
]
</pre>
<h3 class="clause">5.5.2. status Response</h3>
<p>
Server implementation of the "/meta/status" channel is OPTIONAL.  If a bayeux server supports the "/meta/status" channel, then the server SHOULD respond to a status request with a status response.
</p>
  A status response must contain the follow fields
<dl>
<dt>channel</dt><dd>value "/meta/status"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
<dt>successful</dt><dd>boolean indicating the success or failure of the connection</dd>
</dl>
A status response MAY contain the message fields:
<dl>
<dt>ext</dt><dd>This field is server dependent and typically returns status data.
</dl>
An example status response is:
<pre class="example">
[
  {
     "channel": "/meta/status",
     "clientId": "Un1q31d3nt1f13rî,
     "ext":  {"org.dojo.bayeux.status": {"serverTopics": {"topic1", "topic2", "topic3"} } }
   }
]
</pre>
<div style="color:red;"><b> END REMOVAL SECTION</b></div>




<h2 class="clause">5.6. subscribe</h2>
<h3 class="clause">5.6.1. subscribe Request</h3>
<p>A connected bayeux client may send subscribe messages to register interest in a channel and to request that messages published to the subscribe channel are delivered to the client.
</p>
A subscribe request MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/subscribe"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
<dt>subscription</dt><dd>a channel name or a channel pattern or an array of channel names and channel patterns.</dd>
</dl>
A connect request MAY contain the message fields:
<dl>
<dt>ext</dt>
</dl>
An example subscribe request is:
<pre class="example">
[
  {
     "channel": "/meta/subscribe",
     "clientId": "Un1q31d3nt1f13r",
     "subscription": "/foo/**"
   }
]
</pre>

<h3 class="clause">5.6.2. subscribe Response</h3>
<p>
A bayeux server MUST respond to a subscribe request with a subscribe response message.
A bayeux server MAY send event messages for the client in the same http response as the subscribe response, including events for the channels just subscribed to.
</p>
A subscribe responses MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/subscribe"</dd>
<dt>successful</dt><dd>boolean indicating the success or failure of the connection</dd>
<dt>clientId</dt><dd>The negotiated client ID</dd>
</dl>
A connect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>ext</dt>
<dt>timestamp</dt>
</dl>
An example subscribe response is:
<pre class="example">
[
  {
     "channel": "/meta/subscribe",
     "clientId": "Un1q31d3nt1f13r",
     "subscription": "/foo/**",
     "successful": true,
     "error": ""
   }
]
</pre>


<h2 class="clause">5.7. unsubscribe</h2>
<h3 class="clause">5.7.1. unsubscribe Request</h3>
<p>A connected bayeux client may send unsubscribe messages to cancel interest in a channel and to stop published message delivery from the server to the unsubscribe channel.
</p>
A unsubscribe request MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/unsubscribe"</dd>
<dt>clientId</dt><dd>The client ID returned in the handshake response</dd>
<dt>subscription</dt><dd>a channel name or a channel pattern or an array of channel names and channel patterns.</dd>
</dl>
A connect request MAY contain the message fields:
<dl>
<dt>ext</dt>
</dl>
An example unsubscribe request is:
<pre class="example">
[
  {
     "channel": "/meta/unsubscribe",
     "clientId": "Un1q31d3nt1f13r",
     "subscription": "/foo/**"
   }
]
</pre>

<h3 class="clause">5.7.2. unsubscribe Response</h3>
<p>
A bayeux server MUST respond to a unsubscribe request with a unsubscribe response message.
A bayeux server MAY send event messages for the client in the same http response as the unsubscribe response, including events for the channels just unsubscribed to as
 long as the event was processed before the unsubscribe request.
</p>
A unsubscribe responses MUST contain the message fields:
<dl>
<dt>channel</dt><dd>value "/meta/unsubscribe"</dd>
<dt>successful</dt><dd>boolean indicating the success or failure of the connection</dd>
<dt>clientId</dt><dd>The negotiated client ID</dd>
</dl>
A connect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>ext</dt>
<dt>timestamp</dt>
</dl>
An example unsubscribe response is:
<pre class="example">
[
  {
     "channel": "/meta/unsubscribe",
     "clientId": "Un1q31d3nt1f13r",
     "subscription": "/foo/**",
     "successful": true,
     "error": ""
   }
]
</pre>









<h2 class="clause">5.8. ping</h2>
<h3 class="clause">5.8.1. ping Request</h3>
<h3 class="clause">5.8.2. ping Response</h3>


<h1 class="clause">6. Event Message Definitions</h1>
Application events are published in event messages sent from a bayeux client to a bayeux server and are delivered in event messages sent from a bayeux server to a bayeux client.


<h2 class="clause">6.1. Publish event messages</h2>

<h3 class="clause">6.1.1. publish Request</h3>
<p>
A bayeux client can publish events on a channel by sending event messages.
An event message MAY be sent in new HTTP request or it MAY be sent in the same HTTP request as 
any message other than a handshake meta message.  
If sent with a connect meta message, the event messages MUST be processed after the connect message 
and if the connect is unsuccessful, the messages MAY be discarded.
</p>
A publish event message MUST contain the message fields:
<dl>
<dt>channel</dt><dd></dd>
<dt>clientId</dt><dd>The negotiated client ID</dd>
<dt>data</dt><dd>The message as arbitrary JSON object</dd>
</dl>
A connect response MAY contain the message fields:
<dl>
<dt>id</dt><dd>A unique ID for the message generated by the client</dd>
<dt>ext</dt>
</dl>
An example event message is:
<pre class="example">
[
  {
     "channel": "/some/channel",
     "clientId": "Un1q31d3nt1f13r",
     "data": "some application string or JSON object",
     "id": "some unique message id"
  }
]
</pre>



<h3 class="clause">6.1.2. publish Response</h3>
<p>
A bayeux server MAY respond to a publish event message with a publish event acknowlegement.
</p>
A publish event message MUST contain the message fields:
<dl>
<dt>channel</dt><dd></dd>
<dt>clientId</dt><dd>The negotiated client ID</dd>
<dt>successful</dt><dd>boolean indicating the success or otherwise of the publish</dd>
</dl>
A publish event response MAY contain the message fields:
<dl>
<dt>id</dt>
<dt>error</dt>
<dt>ext</dt>
</dl>
An example event message is:
<pre class="example">
[
  {
     "channel": "/some/channel",
     "clientId": "Un1q31d3nt1f13r",
     "data": "some application string or JSON object",
     "id": "some unique message id"
  }
]
</pre>

<p>

<h2 class="clause">6.2. Deliver Event messages</h2>

<p>
Event messages are delivered to clients if the client is subscribed to the channel of the event message.
Event messages may be sent to the client in the same HTTP response as any other message other than a meta handshake response.
If a bayeux server has multiple HTTP requests from the same client, the server SHOULD deliver all available messages in HTTP response 
that will be sent immediately in preference to waking a waiting reconnect meta message handler.
Event message deliver is not acknowlegded by the client.
</p>

<p>
A deliver event message MUST contain the message fields:
</p>
<dl>
<dt>channel</dt><dd></dd>
<dt>data</dt><dd>The message as arbitrary JSON object</dd>
</dl>
A deliver event response MAY contain the message fields:
<dl>
<dt>id</dt><dd>Unique message ID from the publisher</dd>
<dt>clientId</dt><dd>The client ID of the publisher</dd>
<dt>ext</dt>
<dt>advice</dt>
</dl>
An example event deliver message is:
<pre class="example">
[
  {
     "channel": "/some/channel",
     "data": "some application string or JSON object",
     "id": "some unique message id"
  }
]
</pre>



<h1 class="clause">7. Transports</h1>
<h2 class="clause">7.1. long-polling</h2>
messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. 
Messages are sent to the client as unencapsulated body content of a POST response. 
<span class="note">Should we support commented json to protect against hijacking</span>
<h2 class="clause">7.2. callback-polling</h2>
<h2 class="clause">7.3. iframe</h2>
<h1 class="clause">8. Security</h1>

<h2 class="clause">8.1. Authentication</h2>
Bayeux may be used with:
<ul>
<li>No authentication</li>
<li>Container supplied authentication (eg BASIC auth or cookie managed session based
authentication)</li>
<li>Bayeux extension authentication that exchanges authentication credentials and tokens within
Bayeux messages ext fields</li>
</ul>
<p>
For Bayeux authentication, no algorithm is specified for generating or validating security
credentials or token. This version of the protocol only defines that the ext field may be used
to exchange authentication challenges, credentials and tokens and that the advice field may be
used to control multiple iterations of the exchange.
</p>
<p>
The connection negotiation mechanism may be used to negotiate authentication or request
re-authentication.
</p>

<h2 class="clause">8.2. Ajax Hijacking</h2>
<p>
The Ajax hijacking vulnerability is when an attacking web site uses a script tag to execute JSON content obtained from an Ajax server. The Bayeux protocol is 
not vulnerable to this style of attack as cookies are not used for authentication and a valid client ID is needed before private client data is returned.  The use of POST requests
further protects against this style of attack.  
</p>
<p>
To futher protect against this class of attack, it is RECOMMEDED that Bayeux clients and servers support json comment filtered format, where the outer JSON array is enclosed in
a comment that will prevent execution of the JSON without explicit handling of the comment characters. An example of a commented message is:</p>
<pre class="example">
/*[
  {
     "channel": "/some/channel",
     "data": "some application string or JSON object",
     "id": "some unique message id"
  }
]*/
</pre>
<p>An extension field of json-comment-filtered should be sent by client and server to indicate that comment-filtering is supported. 
If it is, the content-type should be text/json-comment-filtered.
</p>

<h1 class="clause">9. Multi frame operation</h1>
<p>Current HTTP client implementations are RECOMMENDED to allow only two connections between a client and a server.  This presents a problem when multiple instances of the bayeux client are operating
in multiple tabs or windows of the same browser instance.   The two connection limit can be consumed by outstanding reconnect meta messages from each tab or window and thus prevent 
other messages from being delivered in a timely fashion.
</p>

<h2 class="clause">9.1 Server Multi frame detection</h2>
<p>
It is RECOMMENDED that bayeux server implementations use the cookie "BAYEUX_HTTP_ID" to identify a HTTP client and to thus detect multiple bayeux clients running within the same HTTP
client.  Once detected, the server SHOULD not wait for messages in reconnect and SHOULD use the advice interval mechanism to establish traditional polling.
</p>

<h2 class="clause">9.1 Client Multi frame handling</h2>
<p>
It is RECOMMENDED that bayeux client implementations use client side persistence or cookies to detect multiple intances of bayeux clients running within the same HTTP client.
Once detected, the user MAY be offered the option to disconnect all but one of the clients.  It MAY be possible for client implementations to use client side persistence to 
share a bayeux client instance. 
</p>




