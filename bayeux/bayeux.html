
<html>
<head>
<style>
body { font-family: san-serif ; margin-left: 25pt;}
h1.title { text-align: center }
h1.intro { text-align: center }
.note{ color: red }

h1,h2,h3,h4 {margin-left: -20pt; margin-bottom: 2pt; }

table.info { width: 100% ;}
pre { margin-left: 25pt; }
dl { margin-left: 25pt; }
dt { font-weight: bold }

</style>
</head>
<body>


<h1 class="title">Dojo Foundation</h1>

<table class="info">
<tr>
<td>
<b>Request for Comments:</b> not an RFC<br/>
<b>Obsoletes:</b> protocol.txt<br/>
<b>Category:</b> Standards Track<br/>
</td>
<td>
Alex Russel<br/>
David Davis<br/>
Greg Wilkins<br/>
</td>
</tr>
</table>

<h1 class="intro">Bayeux Protocol -- Bayeux 0.1draft5</h1>
<h2 class="intro">Status of this Memo</h2>
This document specifies an protocol for the Internet community, and requests discussion and suggestions for improvement. This memo is written in the style and spirit of an RFC but is not, as of yet, an official RFC. Distribution of this memo is unlimited.
This memo is written in UK English.
<p>
<span class="note">This memo is currently incomplete and content has yet to be moved from the protocol.txt file</span>
</p>
<h2 class="intro">Copyright Notice</h2>
Copyright &copy; The Dojo Foundation (2007). All Rights Reserved
<h2 class="intro">Abstract</h2>
<span class="note">
Blurb about what cometd is, about what bayeux is and HTTP and how it is all so difficult and we are all so brilliant for fixing it!   HTTP is client server blah blah....two connection limit blah blah.... cross context dispatch blah blah. imlementation language neutral blah blah
</span>
<h1 class="contents">Table of Contents</h1>
TBD

<h1 class="clause">1. Introduction</h1>
<h2 class="clause">1.1. Purpose</h2>

Bayeux is a protocol for transporting asynchronous messages over HTTP. The messages are routed via named channels and can be delivered: server to client, client to server and client to client (via the server). The primary purpose of Bayeux is to implement Web 2.0 solutions using Ajax and the Ajax push technique called cometd.
Not sure how this differs from the Abstract above... but eitherway some more blurbage should be here.






<h2 class="clause">1.2. Requirements</h2>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC2119. 
An implementation is not compliant if it fails to satisfy one or more of the MUST or REQUIRED level requirements for the protocols it implements. An implementation that satisfies all the MUST or REQUIRED level and all the SHOULD level requirements for its protocols is said to be "unconditionally compliant"; one that satisfies all the MUST level requirements but not all the SHOULD level requirements for its protocols is said to be "conditionally compliant."
<h2 class="clause">1.3. Terminology</h2>


This specification uses a number of terms to refer to the roles played by participants in, and objects of, the Bayeux communication:
<dl>
<dt>client</dt>
<dd>program that establishes connections for the purpose of sending HTTP requests.</dd>
<dt>server</dt>
<dd>An application program that accepts TCP/IP connections in order to service HTTP requests by sending back HTTP responses. </dd>
<dt>request</dt>
<dd>An HTTP request message as defined by section 5 of RFC 2616</dd>
<dt>response</dt>
<dd>A HTTP response message as defined by section 6 of RFC 2616</dd>
<dt>message</dt>
<dd>A message is a JSON object exchanged between client and server for the purposed of implementing the bayeux protocol as defined by section <span class="note">XXX</span></dd>
<dt>event</dt>
<dd>Application specific data that is sent over the bayeux protocol</dd>
<dt>envelope</dt>
<dd>The transport specific message formate that wraps a standard bayeux message.</dd>
<dt>channel</dt>
<dd>A named destination and/or source of events. Events are published to channels and subscribers to channels receive the published events.</dd>
<dt>connection</dt>
<dd><span class="note">blah blah blah</span></dd>
<dt>JSON</dt>
<dd>JavaScript Object Notation is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999. JSON is described at http://www.json.org/ </dd>
</dl>





<h2 class="clause">1.4. Overall Operation</h2>
<h3 class="clause">1.4.1. HTTP </h3>
The HTTP protocol is a request/response protocol. A client sends a request to the server in the form of a request method, URI, and protocol version, followed by a MIME-like message containing request modifiers, client information, and optional body content over a connection with a server. The server responds with a status line, including the message's protocol version and a success or error code, followed by a MIME-like message containing server information, entity metainformation, and possible entity-body content. 
The server may not initiate a connection with a client nor send an unrequested response to the client, thus asynchronous events cannot be delivered from server to client unless a previously issued request exists. In order to allow two way asynchronous communication, bayeux supports the use of multiple HTTP connections between a client and server, so that previously issued requests are available to transport server to client messages.
The recommendation of section 8.1.4 of RFC 2616 is that a single user client SHOULD NOT maintain more than 2 connection with any server, so XXX
<h3 class="clause">1.4.2. Javascipt</h3>
The majority of Bayeux clients will be implemented in javascript and will be running within the security framework of a client browser.
Say something about x-domain scripting.
<h3 class="clause">1.4.3. Client to Server Event exchange</h3>
A bayeux message is sent from the client to the server via a HTTP request initiated by a user agent and transmitted to an origin server via a chain of zero or more intermediaries (proxy, gateway or tunnel):
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | --M0(E)--> |            |              |            |
 |            | ---HTTP request(M0(E))--> |            |
 |            |            |              | --M0(E)--> |
 |            |            |              | <---M1---- |
 |            | <---HTTP response(M1)---- |            |
 | <---M1---  |            |              |            |
</pre>
The figure above represents a bayeux event E encapsulted in a bayeux message M0 being sent from a bayeux client BC to a bayeux server BS via HTTP request transmitted from a User Agent U to to an Origin server O via a proxy P. The HTTP response contains another bayeux message M1 that will at  contain the protocol response to M0, but may contain other bayeux events initiated on the server or on other clients.
<h3 class="clause">1.4.4. Server to Client Message exchange</h3>
A bayeux message is sent from the server to the client via a HTTP response to a HTTP request  sent in anticipation by a user agent and transmitted to an origin server via a chain of zero or more intermediaries (proxy, gateway or tunnel):
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | --- HTTP request(M0) ---> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E)-- |
 |            | <--HTTP response(M1(E))-- |            |
 | <--M1(E)-- |            |              |            |
 | ---M2--->  |            |              |            |
 |            | --- HTTP request(M2) ---> |            |
 |            |            |              | ----M2---> |
 ~            ~            ~              ~            ~ wait
</pre>
The figure above represents a bayeux message M0 being sent from a bayeux client BC to a bayeux server BS via HTTP request transmitted from a User Agent U to to an Origin server O via a proxy P. The message M0 is sent in anticipation of an bayeux event to be delivered from server to client and the bayeux server waits for such an event before sending a response.  A bayeux event E is shown being delivered via bayeux message M1 in the HTTP response. M1 may contain other bayeux events or an indication that no events were available after a configured timeout. 
On receipt of the HTTP response cotaining M1, the bayeux client issues a new bayeux message M2 in anticipation of more events to be delivered from server to client.
This techique is called long polling.
<h3 class="clause">1.4.5. Streaming transports</h3>
Some bayeux transports use a streaming technique (also called a forever response) that allows multiple messages to be sent over the same HTTP response:

<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | --- HTTP request(M0) ---> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E0)- |
 |            | <--HTTP response(M1(E0))- |            |
 | <--M1(E0)- |            |              |            |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <--M1(E1)- |
 |            | <----(M1(E1))------------ |            |
 | <--M1(E1)- |            |              |            |
 ~            ~            ~              ~            ~ wait
</pre>
These techiques avoid the latency and extra messaging of anticipatory requests, but is subject to the implementation of user agents and proxies as it requires non complete HTTP responses to be delivered to the bayeux client.
<h3 class="clause">1.4.6. Two connection operation</h3>
In order to operation by-direction communications, a bayeux client will use two HTTP connections to a bayeux server so that both server to client and client to server messaging may occur asynchronously:
<pre class="example">
BC ---------- U ---------- P ------------ O ---------- BS
 | ---M0--->  |            |              |            |
 |            | ------ req0(M0) --------> |            |
 |            |            |              | ----M0---> |
 ~            ~            ~              ~            ~ wait
 | --M1(E1)-> |            |              |            |
 |            | ----- req1(M1(E1))------> |            |
 |            |            |              | --M1(E1)-> |
 |            |            |              | <---M2---- |
 |            | <---- resp1(M2)---------- |            |
 | <---M2---  |            |              |            |
 ~            ~            ~              ~            ~ wait
 |            |            |              | <-M3(E2)-- |
 |            | <-----resp2(M3(E2))------ |            |
 | <-M3(E2)-- |            |              |            |
 | ---M4--->  |            |              |            |
 |            | ------req3(M4)----------> |            |
 |            |            |              | ----M4---> |
 ~            ~            ~              ~            ~ wait
</pre>
HTTP requests req0 and req1 are sent on different TCP/IP connections, so that the response to req1 may be sent before the response to req0.   Implementations MUST control HTTP pipelining so that req1 does not get queued behind req0 and thus enforce an ordering of responses.
<h3 class="clause">1.4.7. Connection Negotiation</h3>
<span class="note">blah blah blah</span>
<pre class="example">
BC ----------------------------------------- BS
 | ------------------ handshake request ---> |
 | <---- handshake response ---------------- |
 | -------------------- connect request ---> |
 | <---- connect response ------------------ |
 | ------------------ reconnect request ---> |
 ~                                           ~ wait
 | ------------------- message request ----> |
 | <---- message response ------------------ |
 | <---- reconnect response ---------------- |
 </pre>
<h3 class="clause">1.4.8. Unconnected operation</h3>
messages can be sent without a prior handshake....<span class="note">blah blah blah</span>
<pre class="example">
 | ------------------- message request ----> |
 | <---- message response ------------------ |
</pre>






<h1 class="clause">2. Protocol values</h1>
<h2 class="clause">2.1. Common Elements</h2>
The characters used for Bayeux names and identifiers are defined by the BNF definitions:
<pre class="example">
alpha    = lowalpha | upalpha

lowalpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" |
           "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" |
           "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

upalpha  = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" |
           "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" |
           "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"

digit    = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
           "8" | "9"

alphanum = alpha | digit

mark     = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"

reserved = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
           "$" | ","

integer  = digit *( digit )
</pre>


<h2 class="clause">2.2. Channel</h2>
Channels are identified by names that are styled as absolute path component of a URI without parameters as defined by RFC2396.
<pre class="example">
channel_name  = "/"  path_segments
path_segments = segment *( "/" segment )
segment       = *pchar
pchar         = alphanum | mark
</pre>
The channel name consists of an initial “/” followed by an optional sequence of path segments separated by a single slash "/" character. Within a path segment, the characters "/", is reserved.
Channel names commencing with "/meta/" are reserved for the use of the protocol.


<h2 class="clause">2.3. Version</h2>
A protocol version is a decimal number:
<pre class="example">
version = integer "." integer
</pre>
<span class="note">
I think we should change this to a string!  otherwise we will get into the issue of what does minimal version mean when we have version 1.9 and 1.10, specially as 1.10 can't be represented as a number differently from 1.1.   I propose that we change the definition to the following:
A protocol version is a integer followed by an optional "." separated sequence of alphanumeric elements:
<pre class="example">
version         = integer *( "." version_element )
version_element = alphanum *( alphanum | "-" | "_" )
</pre>
</span>
versions are compared element by element, applying normal alphanumeric comparison to each element.


<h2 class="clause">2.4. Client ID</h2>
A client ID is an random, non predictable sequence of alpha numeric characters:
clientId   =   alphanum *( alphanum )
Client IDs are generated by the server and SHOULD be created with a strong random algorithm that contains at least 128 truly random bits. Servers MUST ensure that client IDs are unique and SHOULD attempt to avoid reuse of client IDs.
<h1 class="clause">3. Messages</h1>
Bayeux messages are JSON encoded objects that contain an unordered sequence of name value pairs representing fields and values. Values may be simple string or numbers or complex JSON encoded objects. bayeux message fields are defined in section [XXX].
A bayeux message MUST contain one and only one channel field [cross reference] . The type of the message is determined by the channel and if the message is sent as part of a request or a response.
All bayeux messages SHOULD be encapsulated in a JSON array, so that multiple messages may be transported together. A bayeux client or servers MUST accept either an array of messages or a single message. The JSON message or array of messages is itself often encapsulated in transport specific formatting and encodings.
Below is an example bayeux message representing an event sent from a client to a server:
<pre class="example">
[
  {
    "channel": "/some/name",
    "clientId": "83js73jsh29sjd92",
    "connectionId": "/meta/connections/83js73jsh29sjd92",
    "data": { "myapp" : "specific data", value: 100 }
  }
]
</pre>
<span class="note">
One could ask why we have both clientId and connectionId.  Surely client Id is sufficient?
</span>





<h1 class="clause">4. Message Field Definitions</h1>
<h2 class="clause">4.1. channel</h2>
The channel message field MUST be included in every Bayeux messages to specify source or destination of the message.  In a request, the channel specifies the destination of the message, and for in a response it specifies the source of the message.
<h2 class="clause">4.2. version</h2>
The version message field SHOULD be included in messages to/from the "/meta/handshake" channel to indicate the protocol version expected by the client/server.
<h2 class="clause">4.3. minimumVersion</h2>
The version message field MAY be included in messages from to/from the "/meta/handshake" channel to indicate the oldest protocol version that can be handled by the client/server.
<h2 class="clause">4.4. authScheme</h2>
The authScheme allows the name of an authentication mechanism to be named in a message to the "/meta/handshake" channel. No schemes are currently defined to be supported.
<h2 class="clause">4.5. authUser</h2>
The authUser allows the name of a user to be passed to the authentication mechanism in message to the "/meta/handshake" channel. The format  and validity of the username depends on the authScheme.
<h2 class="clause">4.6. authToken</h2>
The authUser field allows the authentication credentials to be passed to the authentication mechanism in message to the "/meta/handshake" channel. The format  and validity of the username depends on the authScheme.
<h2 class="clause">4.7. supportedConnectionTypes</h2>

The supportedConnectionTypes field is included in messages to and from the "/meta/handshake" channel to allow clients and servers to reveal the transports that are supported. The value is an array of strings, with each string representing a transport name.  Defined connection types include: 
<dl>
<dt>long-polling</dt>
<dd>messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. Messages are sent to the client as unencapsulated body content of a POST response. This transport is defined in section [XXX] of this memo.</dd>
<dt>callback-polling</dt>
<dd>messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. Responses are sent</dd>
<dt>iframe</dt>
<dd><span class="note">buggered if I know</span></dd>
<dt>mime-message-block</dt>
<dd><span class="note">buggered if I know</span></dd>
<dt>flash</dt>
<dd><span class="note">buggered if I know</span></dd>
</dl>

All server and client implementations MUST support the "long-polling" connection type and SHOULD support "callback-polling". All other connection types are OPTIONAL.
<h2 class="clause">4.8. clientId</h2>
<h2 class="clause">4.9. authSuccessful</h2>
<h2 class="clause">4.10. advice</h2>
<h3 class="clause">4.10.1. reconnect</h3>
<h3 class="clause">4.10.2. interval</h3>
<h2 class="clause">4.11. connectionType</h2>
<h2 class="clause">4.12. id</h2>
<h2 class="clause">4.13. timestamp</h2>
<h2 class="clause">4.14. data</h2>
<h2 class="clause">4.15. connectionId</h2>
<h2 class="clause">4.16. successful</h2>
<h2 class="clause">4.17. subscription</h2>
<h2 class="clause">4.18. error</h2>
<h1 class="clause">5. Message Definitions</h1>
<h2 class="clause">5.1. handshake</h2>
<h3 class="clause">5.1.1. handshake Request</h3>
A bayeux client initiates a connection negotiation by sending a message to the "/meta/handshake" channel. Handshake requests MUST be sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. 
A handshake request MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/handshake"</dd>
<dt>version</dt>
<dd>The version of the protocol supported by the client.</dd>
<dt>supportedConnectionTypes</dt>
<dd>The connection types supported by the client for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type.</dd>
</dl>
A handshake request MAY contain the message fields:
<dl>
<dt>minimumVersion</dt>
<dt>authScheme</dt>
<dt>authUser</dt>
<dt>authToken</dt>
</dl>
A client SHOULD NOT send any other message in the request with a handshake message. A server MUST ignore any other message sent in the same request as a handshake message.
 An example handshake request is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling", "callback-polling", "iframe"],
     "authScheme": "SHA1",
     "authUser": "alex",
     "authToken": "HASHJIBBERISH"
   }
]
</pre>

<h3 class="clause">5.1.2. handshake Response</h3>
A bayeux server MUST respond to a handshake request with a handshake response message in the body content of a  POST response. 
<h4>Successful handshake response</h4>
A successful handshake responses MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/handshake"</dd>
<dt>version</dt>
<dd></dd>
<dt>supportedConnectionTypes</dt>
<dd>The connection types supported by the server for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type. This list MUST contain at list one element in common with the supportedConnectionType provided in the handshake request. If there are no connectionTypes in common, the handshake response MUST be unsuccessful.</dd>
<dt>clientId</dt>
<dd>A newly generated clientId.</dd>
<dt>authSuccessful</dt>
<dd>value true</dd>
</dl>

A successful handshake responses MAY contain the message fields:
<dl>
<dt>minimumVersion</dt>
<dt>authToken</dt>
<dt>advise</dt>
</dl>
An example successful handshake response is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling","callback-polling"],
     "clientId": "Un1q31d3nt1f13r",
     "authSuccessful": true,
     "authToken": "UPDATEDHASHJIBBERISH",
     "advice": { "reconnect": "retry" }
   }
]
</pre>
<h4>Unsuccessful handshake response</h4>
An unsuccessful handshake response MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/handshake"</dd>
<dt>authSuccessful</dt>
<dd>value false</dd>
<dt>error</dt>
<dd>a description of the reason for the failure.</dd>
</dl>
An unsuccessful handshake  response MAY contain the message fields:
<dl>
<dt>supportedConnectionTypes</dt>
<dd>The connection types supported by the server for the purposes of the connection being negotiated.  This list MAY be a subset of the connection types actually supported if the client wishes to negotiate a specific connection type. </dd>
<dt>advice</dt>
<dt>authToken</dt>
<dt>version</dt>
<dt>minimumVersion</dt>
</dl>
An example unsuccessful handshake response is:
<pre class="example">
[
  {
     "channel": "/meta/handshake",
     "version": 0.1,
     "minimumVersion": 0.1,
     "supportedConnectionTypes": ["long-polling","callback-polling"],
     "authSuccessful": false,
     "error": "Authentication failed",
     "advice": { "reconnect": "none" }
   }
]
</pre>








<h2 class="clause">5.2. connect</h2>
<h3 class="clause">5.2.1. connect Request</h3>
After a bayeux client has discovered the servers capabilities with a handshake exchange, a connection is established by sending a message to the "/meta/connect" channel. 
This message may be transported over any of the transported indicated as supported by the server in the handshake response.

A connect request MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/connect"</dd>
<dt>clientId</dt>
<dd>The client ID returned in the handshake response</dd>
<dt>connectionTypes</dt>
<dd>The connection types used by the client for the purposes of this connection.</dd>
</dl>
A connect request MAY contain the message fields:
<dl>
<dt>authToken</dt>
</dl>
A client MAY send other messages in the same http request with a connection message. A server MUST handle any other message sent in the same request as a connect message.
An example connect request is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "clientId": "Un1q31d3nt1f13r",
     "connectionType": "long-polling"
   }
]
</pre>

<h3 class="clause">5.2.2. connect Response</h3>

A bayeux server MUST respond to a connect request with a connect response message over the same transport as used for the request.
A bayeux server MUST respond immediately to a connect request.
A bayeux server MAY send event messages for the client in the same http response as the connect response, but the bayeux server MUST NOT 
wait for any such messages before sending the connect response message.
 
A connect responses MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/connect"</dd>
<dt>successful</dt>
<dd>boolean indicating the success or failure of the connection</dd>
<dt>clientId</dt>
<dd>The negotiated client ID</dd>
</dl>
A successful connect response MUST contain a connectionId message field.
A connect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>timestamp</dt>
</dl>
An example connect response is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "successful": true,
     "error": "",
     "connectionId": /meta/connections/Un1q31d3nt1f13r,
     "clientId": "Un1q31d3nt1f13r",
     "timestamp": "12:00:00 1970",
     "advice": { "reconnect": "retry" }
   }
]
</pre>



<h2 class="clause">5.3. reconnect</h2>
<h3 class="clause">5.3.1. reconnect Request</h3>
In order to maintain a connection established by a connect message exchange, a beyeux client MUST send a message to the "/meta/reconnect" channel
within the timeouts specificied in the advice received in the handshake or connect response. The client MUST maintain only a single outstanding 
reconnect request.

The reconnect message MUST be transported over the same transport indicated indicated in the connect request.

A reconnect requests MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/reconnect"</dd>
<dt>clientId</dt>
<dd>The client ID returned in the handshake response</dd>
<dt>connectionId</dt>
<dd>The connection ID returned in the connect response</dd>
</dl>
reconnect requests MAY contain the message fields:
<dl>
<dt>authToken</dt>
<dt>connectionType</dt>
</dl>
A client MAY send other messages in the same http request with a reconnect message. A server MUST handle any other message sent in the same request as a reconnect message and 
handling of these messages MUST NOT be defered until a response to the reconnect message is available.
An example reconnect request with an event message is:
<pre class="example">
[
  {
     "channel": "/meta/reconnect",
     "clientId": "Un1q31d3nt1f13r",
     "connectionType": "long-polling"
  },
  {
     "channel": "/some/channel",
     "clientId": "Un1q31d3nt1f13r",
     "data": "some data"
  }
]
</pre>


<h3 class="clause">5.3.2. reconnect Response</h3>


A bayeux server MUST respond to a reconnect request with a reconnect response message over the same transport as used for the request.
A bayeux server MAY wait to respond until there are event messages available to be delivered to the client.
A bayeux server MAY send event messages for the client in the same http response as the connect response.
 
A reconnect responses MUST contain the message fields:
<dl>
<dt>channel</dt>
<dd>value "/meta/reconnect"</dd>
<dt>successful</dt>
<dd>boolean indicating the success or failure of the connection</dd>
<dt>connectionId</dt>
<dd>The connection ID of the reconnect request</dd>
</dl>
A reconnect response MAY contain the message fields:
<dl>
<dt>error</dt>
<dt>advice</dt>
<dt>timestamp</dt>
</dl>
An example reconnect response with an event message is:
<pre class="example">
[
  {
     "channel": "/meta/connect",
     "successful": true,
     "error": "",
     "connectionId": /meta/connections/Un1q31d3nt1f13r,
     "timestamp": "12:00:00 1970"
   },
   {
     "channel": "/some/channel",
     "data": "some data"
   }
]
</pre>








<h2 class="clause">5.4. disconnect</h2>
<h3 class="clause">5.4.1. disconnect Request</h3>
<h3 class="clause">5.4.2. disconnect Response</h3>








<h2 class="clause">5.5. status</h2>
<h3 class="clause">5.5.1. status Request</h3>
<h3 class="clause">5.5.2. status Response</h3>









<h2 class="clause">5.6. subscribe</h2>
<h3 class="clause">5.6.1. subscribe Request</h3>
<h3 class="clause">5.6.2. subscribe Response</h3>
<h2 class="clause">5.7. unsubscribe</h2>
<h3 class="clause">5.7.1. unsubscribe Request</h3>
<h3 class="clause">5.7.2. unsubscribe Response</h3>
<h2 class="clause">5.8. ping</h2>
<h3 class="clause">5.8.1. ping Request</h3>
<h3 class="clause">5.8.2. ping Response</h3>
<h2 class="clause">5.9. default</h2>
<h1 class="clause">6. Transports</h1>
<h2 class="clause">6.1. Long-Polling</h2>
messages are sent to the server as the message parameter of a application/x-www-form-urlencoded encoded POST request. Messages are sent to the client as unencapsulated body content of a POST response. 
<span class="note">blah blah blah</span>
<h2 class="clause">6.2. JSONP</h2>
<h1 class="clause">7. Security</h1>

